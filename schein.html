<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Übung (Schein)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Übung (Schein)</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="übersicht-und-allgemeine-hinweise" class="slide section level1">
<h1>Übersicht und allgemeine Hinweise</h1>
<ul>
<li><p>Bearbeiten Sie bitte folgende Aufgaben. Sie erhalten den Schein wenn Sie alle Aufgaben erfolgreich bearbeitet haben (Teilaufgabe 4 SEMANTIK ist freiwillig).</p></li>
<li><p>Sämtliche Aufgaben müssen im Softwarelabor persönlich vorgestellt werden. Abnahme durch den jeweiligen Übungsleiter.</p></li>
<li><p>Notwendige Quellen (&quot;source code&quot;) finden Sie als Teil der Aufgabenbeschreibung.</p></li>
<li><p>Abgabefristen siehe ILIAS</p></li>
</ul>
</div>
<div id="aufgabe-1-erkennen-von-mustern-c" class="slide section level1">
<h1>Aufgabe 1: Erkennen von Mustern (C)</h1>
<p>Implementierungsaufgabe inklusive Anpassung des Unit Testrahmens (siehe Labor &quot;count&quot;).</p>
<h2 id="erkennen-des-längsten-suffix-nach-einem-vorgegebenen-muster">Erkennen des längsten Suffix nach einem vorgegebenen Muster</h2>
<p>Erste Teilaufgabe ist es eine Funktion zu schreiben, die den längsten suffix (Endung) liefert, in der keine zwei hintereinander folgenden Doppelpunkte (::) vorkommen. Als Eingabe betrachte man folgende Strings</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="st">&quot;Ha::ll::o&quot;</span>
<span class="st">&quot;47::11&quot;</span></code></pre></div>
<p>Längste Endungen für obige Beispiele sind</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="st">&quot;o&quot;</span>
<span class="st">&quot;11&quot;</span> </code></pre></div>
<p>Hinweis:</p>
<ul>
<li><p>Der beschreibende Text und die Beispiele widersprechen sich.</p></li>
<li><p>Laut beschreibenden Text liefert extract angewandt auf &quot;47::11&quot; das Ergebnis &quot;:11&quot;.</p></li>
<li><p>Es ist ihre Entscheidung, ob sie als Vorgabe die Beispiele oder den beschreibenden Text benutzen.</p></li>
</ul>
<p>Verwenden Sie folgenden Funktionsprototypen.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* extract(<span class="dt">char</span>* input);</code></pre></div>
<p>In obiger Funktion wird das Ergebnis als return Wert geliefert. Das Ergebnis, ein Zeiger, verweist auf die Stelle im Eingabestring die den längsten suffix (Endung) liefert, in der keine zwei hintereinander folgenden Doppelpunkte (::) vorkommen.</p>
<p>Als Variante, verwenden Sie als Rückgabenwert einen Pointer auf einen Pointer. Wieso reicht ein Pointer nicht aus?</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> extract2(<span class="dt">char</span>* input, <span class="dt">char</span>** output)</code></pre></div>
<h3 id="freiwillige-zusatzaufgabe">Freiwillige Zusatzaufgabe:</h3>
<p>Verallgemeinern Sie Ihre Lösung: Das Muster zur Berechnung des längsten Suffix ist ein zusätzlicher Parameter.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* extract(<span class="dt">char</span>* pattern, <span class="dt">char</span>* input);</code></pre></div>
<h2 id="testrahmen">Testrahmen</h2>
<p>Die zweite Teilaufgabe ist es den Testrahmen von &quot;Count - Zählen von Wörtern&quot; anzupassen. Eine hinreichende Menge von Testfällen sollte zur Verfügung stehen.</p>
<p>Hinweis: Im Falle von &quot;count&quot; ist das erwartete Ergebnis ein Integerwert. Im Falle von &quot;extract&quot; ist dies ein String. Wie können Sie auf Gleichheit zweier Strings prüfen? Beachte. Operator <code>==</code> angewandt auf zwei Zeiger, testet nur, ob die beiden Speicheradressen gleich sind!</p>
<h2 id="source-file">Source file</h2>
<p>Details zum Testrahmen finden sie im Foliensatz &quot;Labor&quot;.</p>
</div>
<div id="aufgabe-2-umdrehen-reverse-eines-strings-c" class="slide section level1">
<h1>Aufgabe 2: Umdrehen (&quot;reverse&quot;) eines Strings (C)</h1>
<p>Implementierungsaufgaben mit Tests (dynamischer Analyse)</p>
<h2 id="teilaufgabe-a-implementierung">Teilaufgabe (a) (Implementierung)</h2>
<p>Implementieren Sie eine Funktion <code>reverse</code> welche einen String umdreht (&quot;reverse&quot;). Z.B. reverse des leeren Strings liefert den leeren String, reverse von &quot;12345&quot; liefer &quot;54321&quot; etc.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* reverse(<span class="dt">char</span> *s);</code></pre></div>
<p>Beachte:</p>
<p>Ein ausreichend grosser String muss angelegt werden welcher den umgedrehten String beschreibt.</p>
<h2 id="teilaufgabe-b-implementierung">Teilaufgabe (b) (Implementierung)</h2>
<p>Gegeben sind folgende Funktionen. Funktion <code>length</code> berechnet die Länge eines Strings. Funktion <code>copy</code> kopiert <code>n</code> Zeichen von einer Quelle (<code>s</code>) in ein Ziel (<code>t</code>). Funktion <code>putBack</code> hängt ein Zeichen hinten an einen String an. Beachte, <code>malloc</code> ist Teil der <code>stdlib.h</code>, diese muss deshalb inkludiert werden.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> length(<span class="dt">char</span> *s) {
  <span class="dt">int</span> n = <span class="dv">0</span>;
  <span class="kw">while</span>(*s != &#39;\<span class="dv">0</span>&#39;) {
    n++;
    s++;
  }
  
  <span class="kw">return</span> n;
}

<span class="co">// Annahme: n ist &gt; 0</span>
<span class="dt">void</span> copy(<span class="dt">char</span>* s, <span class="dt">int</span> n, <span class="dt">char</span>* t) {
  <span class="dt">int</span> i = <span class="dv">0</span>;
  <span class="kw">while</span>(i &lt; n) {
    t[i] = s[i];
    i++;
  }
}

<span class="dt">char</span>* putBack(<span class="dt">char</span>* s, <span class="dt">char</span> c) {
  <span class="dt">const</span> <span class="dt">int</span> n =  length(s);
  <span class="dt">char</span>* r = malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>) * (n<span class="dv">+2</span>));
  copy(s, n, r);
  r[n] = c;
  r[n<span class="dv">+1</span>] = &#39;\<span class="dv">0</span>&#39;;
  <span class="kw">return</span> r;
}</code></pre></div>
<p>Ihre Aufgabe ist es mit Hilfe von <code>putBack</code> eine Funktion <code>reverseRec</code> zu implementieren welche eine String umdreht. In ihrer Implementierung dürfen keine Schleifenkonstrukte wie for, while und do-while vorkommen. Sprich, die Implementierung von <code>reverseRec</code> sollte rekursive erfolgen.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* reverseRec(<span class="dt">char</span> *s);</code></pre></div>
</div>
<div id="aufgabe-3-string-klasse-mit-überladenen-operatoren-c11-rule-of-five" class="slide section level1">
<h1>Aufgabe 3: String Klasse mit überladenen Operatoren (C++11 Rule of Five)</h1>
<p>Ihre Aufgabe ist die Implementierung einer String Klasse. Das Design der Klasse orientiert sich an dem Design der MyInt Klasse bekannt aus der Vorlesung und soll dem &quot;Rule of Five&quot; Designmusster folgen.</p>
<p>Implementierungsaufgabe. Teile der Aufgabe sind vorgegeben. Siehe Anhang &quot;Sourcefiles&quot;.</p>
<h2 id="string-klasse-mit-überladenen-operatoren">String Klasse mit überladenen Operatoren</h2>
<p>Erstellen Sie eine String-Klasse ohne zu Hilfenahme von STL, die es Ihnen erlaubt, den folgenden Code zu schreiben:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main() {
  String s1;
  String s2(<span class="st">&quot;Hello&quot;</span>);
  String s3(s2);
  s1 += s2; s2 = s3;
  cout &lt;&lt; s2 &lt;&lt; endl;
  cout &lt;&lt; s2[ <span class="dv">2</span> ] &lt;&lt; endl;
};</code></pre></div>
<p>Beachte</p>
<ul>
<li><p>Intern soll der String als ein Zeiger auf ein Zeichen dargestellt werden (wie in C).</p></li>
<li><p>Bei der Konstruktion, Kopieren und bei der Zuweisung soll der String dupliziert werden. Sie benötigen daher einen Kopierkonstruktor, Zuweisungsoperator und einen Destruktor</p></li>
<li><p>Folgende Operaten sollen überladen werden: += (Konkatenation), = (Zuweisung) und [] (Arrayzugriff)</p></li>
</ul>
<h2 id="tips-und-hinweise">Tips und Hinweise</h2>
<p>Für den Arrayzugriff <code>string[index]</code> (sprich die überladene Methode) verwenden Sie bitte die folgende Signatur.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span>&amp; <span class="kw">operator</span>[](<span class="dt">int</span> index)</code></pre></div>
<p>Wieso wird eine Referenz auf zurückgegeben? Beachte dass eine Arrayzugriff auch auf der linken Seite einer Zuweisung vorkommen kann.</p>
<p>Unten finden Sie ein mögliches Grundgerüst.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="kw">class</span> String {
 <span class="kw">private</span>:
  <span class="co">// &#39;String&#39; is represented internally as a plain C-style string.</span>
  <span class="dt">int</span> size;
  <span class="dt">char</span>* str;
 <span class="kw">public</span>:
  String() { 
    size = <span class="dv">0</span>;
    str = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">1</span>];
    str[<span class="dv">0</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
  }
  String(<span class="dt">char</span> c) {
    size = <span class="dv">1</span>;
    str = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">2</span>];
    str[<span class="dv">0</span>] = c;
    str[<span class="dv">1</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
  }
  ~String() { <span class="kw">delete</span>[] str; }

  <span class="co">// make friend, so we can access private members</span>
  <span class="kw">friend</span> ostream&amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp;out, String &amp;s);

};

ostream&amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp;out, String &amp;s) {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;s.size; i++) {
    out &lt;&lt; s.str[i];
  }

  <span class="kw">return</span> out;
}


<span class="dt">int</span> main() {
  String s;
  String s2(<span class="st">&#39;H&#39;</span>);

  cout &lt;&lt; s &lt;&lt; endl;
  cout &lt;&lt; s2 &lt;&lt; endl;

}</code></pre></div>
<h2 id="sourcefiles">Sourcefiles</h2>
<p>Verwenden Sie folgende Sourcefiles.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// String.h</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> String {
 <span class="kw">private</span>:
  <span class="co">// &#39;String&#39; is represented internally as a plain C-style string.</span>
  <span class="dt">int</span> size;
  <span class="dt">char</span>* str;
 <span class="kw">public</span>:
  String();
  String(<span class="dt">char</span> c);
  String(<span class="dt">const</span> <span class="dt">char</span> *);
  String(<span class="dt">const</span> String&amp;);
  String(String&amp;&amp;);
  ~String();

  <span class="dt">char</span>&amp; <span class="kw">operator</span>[](<span class="dt">int</span> index);
  String&amp; <span class="kw">operator</span>=(<span class="dt">const</span> String&amp;);
    String&amp; <span class="kw">operator</span>=(String&amp;&amp;);
  String&amp; <span class="kw">operator</span>+=(String&amp;);

  <span class="co">// make friend, so we can access private members</span>
  <span class="kw">friend</span> ostream&amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp;out, String &amp;s);

};</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// String.cpp</span>
<span class="ot">#include &lt;iostream&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;String.h&quot;</span>


String::String() { 
    size = <span class="dv">0</span>;
    str = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">1</span>];
    str[<span class="dv">0</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
}


String::String(<span class="dt">char</span> c) {
    size = <span class="dv">1</span>;
    str = <span class="kw">new</span> <span class="dt">char</span>[<span class="dv">2</span>];
    str[<span class="dv">0</span>] = c;
    str[<span class="dv">1</span>] = <span class="st">&#39;</span><span class="ch">\0</span><span class="st">&#39;</span>;
}

String::String(<span class="dt">const</span> <span class="dt">char</span> *s) {
  <span class="co">// TODO</span>
}

String::String(<span class="dt">const</span> String&amp; s) {
  <span class="co">// TODO</span>
}

String::String(String&amp;&amp; s) {
  <span class="co">// TODO</span>
}

String::~String() { <span class="kw">delete</span>[] str; }

<span class="dt">char</span>&amp; String::<span class="kw">operator</span>[](<span class="dt">int</span> index) {
  <span class="co">// TODO</span>
}

String&amp; String::<span class="kw">operator</span>=(String&amp; s) {
  <span class="co">// TODO</span>
  }

String&amp; String::<span class="kw">operator</span>=(String&amp;&amp; s) {
  <span class="co">// TODO</span>
}

String&amp; String::<span class="kw">operator</span>+=(String&amp; s) {
  <span class="co">// TODO</span>
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;String.h&quot;</span>

ostream&amp; <span class="kw">operator</span>&lt;&lt; (ostream &amp;out, String &amp;s) {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;s.size; i++) {
    out &lt;&lt; s.str[i];
  }

  <span class="kw">return</span> out;
}


<span class="dt">int</span> main() {
  String s;
  String s2(<span class="st">&#39;H&#39;</span>);

  cout &lt;&lt; s &lt;&lt; endl;
  cout &lt;&lt; s2 &lt;&lt; endl;

}</code></pre></div>
</div>
<div id="aufgabe-4-parserinterpretercompiler-für-arithemtische-ausdrücke-c11" class="slide section level1">
<h1>Aufgabe 4: Parser/Interpreter/Compiler für arithemtische Ausdrücke (C++11)</h1>
<p>Implementierungsaufgabe. Grosse Teile der Aufgabe sind schon vorgegeben. Siehe &quot;Sourcefiles&quot;. Es gilt 2 Teilaufgaben zu bearbeiten.</p>
<p>SYNTAX: Ziel ist die Vereinfachung von arithmetischen Ausdrücken (Elimination von Klammern).</p>
<p>SEMANTIK: Ziel ist Übersetzung von Ausdrücken in eine Stack-basierte virtuelle Maschine (VM).</p>
<p>Teilaufgabe SYNTAX ist für den Erhalt des Scheins zwingend notwendig.</p>
<p>Teilaufgabe SEMANTIK ist freiwillig (aber Klausurrelevant).</p>
</div>
<div id="teilaufgabe-4-syntax" class="slide section level1">
<h1>Teilaufgabe 4: SYNTAX</h1>
<h2 id="syntax">Syntax</h2>
<p>Wie sieht ein (syntaktisch) wohlgeformter arithmetischer Ausdruck aus?</p>
<p>Beispiele</p>
<pre><code>1, 2, ...

1 + 2

(1 + 3) * 2

...</code></pre>
<p>Formalere Sicht.</p>
<p>E ist ein arithmetischer Ausdruck genau dann wenn (gdw)</p>
<ul>
<li><p>E ist eine Zahl</p></li>
<li><p>E ist ein zusammengesetzter Ausruck E1+E2, E1*E2 wobei jeweils E1, E2 arithmetische Ausdrücke sind</p></li>
<li><p>E ist ein geklammerter Ausdruck (E1) wbei E1 ein aritmetischer Ausdruck ist.</p></li>
</ul>
<p>Aha, die Regeln zur Beschreibung von arithmetischen Ausdrücken entsprechen Regel einer kontext-freien Grammatik</p>
<pre><code>E -&gt; 0
E -&gt; 1
...
...
E -&gt; E + E
E -&gt; E * E
E -&gt; (E)</code></pre>
<p>Hm, Regeln aufwändig für Zahlen allgemein</p>
<pre><code>E -&gt; N
N -&gt; 0
...
N -&gt; 9
N -&gt; 0N
...
N -&gt; 9N</code></pre>
<p>Kann stark vereinfacht werden mit Hilfe von regulären Ausdrücken! Z.B.</p>
<pre><code>E -&gt; [&#39;0&#39;-&#39;9&#39;]+</code></pre>
<p>wobei <code>r+ = r r*</code>. Sprich, einmalige Wiederholung von <code>r</code> gefolgt von <code>r+</code>. Wir schreiben <code>['0'-'9']</code> als Kurznotation für <code>'0'|...|'9'</code>.</p>
<p>Es gibt eine Reihen von Metasyntax Notationen zur Beschreibung von kontext-freien Sprachen. Siehe z.B. <a href="https://en.wikipedia.org/wiki/Extended_Backus-Naur_form">Extended Backus–Naur form</a>.</p>
<h3 id="unsere-syntax-von-arithmetischen-ausdrücken">Unsere Syntax von arithmetischen Ausdrücken</h3>
<p>Angelehnt an <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>, betrachten wir folgende Syntax. Der Einfachheithalber betrachten wir nur die Zahlen, 0, 1 und 2.</p>
<pre><code> N ::= 0 | 1 | 2 

 E ::= N | (E) | E + E | E * E</code></pre>
<p>Wir bezeichnen N und E als Nicht-Terminal Symbole und 0, 1, 2, (, ), + und * als Terminal Symbole.</p>
<p>Was fällt auf? Die EBNF Grammatik ist nicht eindeutig!. D.h. für ein Wort gibt es zwei verschiedene Ableitungen.</p>
<pre><code> (1) 
          E
       -&gt; E + E
       -&gt; N + E
       -&gt; 1 + E
       -&gt; 1 + E * E
       -&gt; 1 + N * E
       -&gt; 1 + 2 * E
       -&gt; 1 + 2 * N
       -&gt; 1 + 2 * 1</code></pre>
<pre><code> (2)

          E
       -&gt; E * E
       -&gt; E + E * E
       -&gt; 1 + E * E
       -&gt; 1 + 2 * E
       -&gt; 1 + 2 * 1</code></pre>
<p>Was ist die Konsequenz verschiedener Ableitungen? Im Fall von (1) wird das Wort &quot;1 + 2 * 1&quot; interpretiert als <code>1 + (2 * 1)</code>. Im Fall von (2) wird das Wort &quot;1 + 2 * 1&quot; interpretiert als <code>(1 + 2) * 1</code>.</p>
<p>Eindeutige Grammatik (bzw. Regeln welche Nicht-eindeutigkeiten Einschränkungen) sind wichtig. Weil sonst könnte Compiler A (Oracle) die Interpretation (1) verwenden und Compiler B (Microsoft) die Interpretation (2). Deshalb sollte wir eine eindeutige Beschreibung (der Syntax) von arithmetischen Ausdrücken haben.</p>
<p>In der Regel gehen wir von &quot;Punkt vor Strich&quot; aus. Gibt es eine äquivalente (eindeutige) Grammatik welche die &quot;Punkt vor Strich&quot; umsetzt? Ja. Betrachte folgende Grammatik.</p>
<pre><code>E ::= E + T | T

T ::= T * F | F

F ::= N | (E)</code></pre>
<p>Betrachte Beispiel von oben.</p>
<pre><code>          E
       -&gt; E + T
       -&gt; E + T * F
       -&gt; T + T * F
       -&gt; F + T * F
       -&gt; F + F * F
       -&gt; N + F * F
       -&gt; 1 + F * F
       -&gt; 1 + N * F
       -&gt; 1 + 2 * F
       -&gt; 1 + 2 * N
       -&gt; 1 + 2 * 1</code></pre>
<p>Interpretiert als <code>1 + (2 * 1)</code>.</p>
<h3 id="darstellung-in-c">Darstellung in C++</h3>
<p>Wie kann die Syntax in C++ dargestellt werden? Idee: Basisklassung mit Vererbung.</p>
<p>Unten finden Sie eine Skizze. Beachte. Die Skizze ist stark vereinfacht im Vergleich zur Implementierung die Ihnen zur Verfügung gestellt ist.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Exp {};

<span class="kw">class</span> IntExp : Exp {
   <span class="dt">int</span> val;
   IntExp(<span class="dt">int</span> x) { val = x; }
};

<span class="kw">class</span> PlusExp : Exp {
   Exp l,r;
   PlusExp(Exp x,y) { l = x; r = y; }
};

<span class="kw">class</span> MultExp : Exp {
   Exp l,r;
   MultExp(Exp x,y) { l = x; r = y; }
};</code></pre></div>
<p>Beachte. Klammerung muss nicht in C++ dargestellt werden. Implizit behandelt durch Klammerung der jeweiligen Objekte.</p>
<p>Beispiel.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="st">&quot;1 + (3 + 5)&quot;</span>

==&gt;

PlusExp(IntExp(<span class="dv">1</span>), PlusExp(IntExp(<span class="dv">3</span>), IntExp(<span class="dv">5</span>)))</code></pre></div>
<p>Aha! In der C++ Darstellung ist die &quot;Klammerung&quot; implizit garantiert durch die Struktur des Objekts!</p>
<h3 id="konkrete-versus-abstrakte-syntax">Konkrete versus Abstrakte Syntax</h3>
<p>Die EBNF Darstellung der Grammatik wird als <b>konkrete Syntax</b> bezeichnet. Dies ist die Syntax wie sie die Programmerin sieht.</p>
<p>Die C++ Darstellung der Grammatik wird als <b>abstrakte Syntax</b> bezeichnet. Dies ist die Syntax von der Maschine verwendet, zur weiteren Verarbeitung des Programms.</p>
<p>Das Objekt</p>
<pre><code>PlusExp(IntExp(1), PlusExp(IntExp(3), IntExp(5)))</code></pre>
<p>stellt einen <b>abstrakten Syntax Baum</b> dar. Wir betrachten Aufrufe des Konstruktors <code>IntExp</code> als Blätter und Aufrufe von <code>PlusExp</code> und <code>MultExp</code> als (Zwischen)knoten, wobei Argumente Kinderknoten dartellen. Z.B.</p>
<pre><code>                          PlusExp
             /       \
             IntExp(1)        PlusExp
                              /       \
                         IntExp(3)   IntExp(5)</code></pre>
<p>Im Englischen wird der abstrake Syntax Baum als &quot;abstract syntax tree (AST)&quot; bezeichnet. Wir verwenden daher oft die Abkürzung AST wenn wir auf den abstrakten Syntax Baum uns beziehen.</p>
<h3 id="syntax-analyse-parserparsing">Syntax Analyse (Parser/Parsing)</h3>
<p>Parsing beschreibt den Vorgang welcher</p>
<ul>
<li><p>erkennt, ob ein Wort Teil der konkreten Syntax (Grammatik) ist, <em>und</em></p></li>
<li><p>(im Erfolgsfall) einen abstrakten Syntaxbaum liefert.</p></li>
</ul>
<p>Ein Parser wird Ihnen zur Verfügung gestellt. Dessen Funktionsweise wird in der Vorlesung im Detail besprochen.</p>
<h3 id="teilaufgabe-syntax">Teilaufgabe SYNTAX</h3>
<p>Der ihnen zur Verfügung gestellte Programmcode kommt mit einem &quot;pretty printer&quot; welcher den AST in eine String umwandelt. Unser &quot;pretty printer&quot; ist sehr einfach gestrickt. Z.B. pretty-printing von</p>
<pre><code>                          PlusExp
             /       \
               IntExp(1)      PlusExp
                             /       \
                        IntExp(3)   IntExp(5)</code></pre>
<p>liefert den String</p>
<pre><code> (1 + (3 + 5))</code></pre>
<p>Sprich, jeder Ausdruck bestehend aus einem binären Operator wird geklammert. Durch die Klammerung wird gesichert, dass sich die Bedeutung des Ausdrucks nicht ändert.</p>
<p>Betrachte den AST</p>
<pre><code>                          MultExp
             /       \
               IntExp(1)      PlusExp
                             /       \
                       IntExp(3)   IntExp(5)</code></pre>
<p>für welchen pretty printing folgenden String liefert.</p>
<pre><code> (1 * (3 + 5))</code></pre>
<p>Durch die Klammern wird der Ausdruck aber schwer(er) lesbar. Ziel dieser Teilaufgabe ist es einen &quot;cleveren&quot; pretty printer zu bauen, welcher soviele Klammern wie möglich eliminert.</p>
<p>Es folgende Beispiele, welche ihre clevere pretty print Variant handhaben sollte.</p>
<p>Für den AST</p>
<pre><code>                         PlusExp
             /       \
             IntExp(1)        PlusExp
                             /       \
                        IntExp(3)   IntExp(5)</code></pre>
<p>die clevere pretty print Variante, sollte folgenden String liefern</p>
<pre><code>1 + 3 + 5</code></pre>
<p>Da + assoziativ is eliminiere alle Klammern.</p>
<p>Für den AST</p>
<pre><code>                          PlusExp
             /       \
             IntExp(1)         MultExp
                              /       \
                          IntExp(3)   IntExp(5)
</code></pre>
<p>die clevere pretty print Variante, sollte folgenden String liefern</p>
<pre><code>1 + 3 * 5</code></pre>
<p>Wir gehen von &quot;Punkt vor Strich&quot; aus. Deshalb eliminiere alle Klammern.</p>
<p>Für den AST</p>
<pre><code>                          MultExp
             /       \
              IntExp(1)        PlusExp
                              /       \
                        IntExp(3)   IntExp(5)</code></pre>
<p>die clevere pretty print Variante, sollte folgenden String liefern</p>
<pre><code>1 * (3 + 5)</code></pre>
<p>Die Klammer <code>(3 + 5)</code> kann nicht elminiert werden, da sich sonst die Bedeutung des Ausdrucks ändert.</p>
<p>Hinweis: Wie können Sie ihre Lösung testen? Parsen der &quot;naiven&quot; (gegebenen) pretty print Variant und ihrer &quot;cleveren&quot; Variante, sollte den gleichen AST liefern. Beachte, der AST mag nicht notwendigerweise syntaktisch gleich sein.</p>
<p>Betrachte folgendes Beispiel.</p>
<pre><code>Ausdruck

1 + (2 + 3)


liefert den AST

    PlusExp
    /     \
   1      PlusExp
          /    \
         2      3

Die clevere pretty Variante liefert den Ausdruck

1 + 2 + 3


Dieser (geparsed) ergibt den AST

         PlusExp
         /     \
     PlusExp    3
     /     \
     1     2


Die ASTs sind syntaktisch verschieden.
Unter der Annahme, dass Addition (+) assoziativ ist,
sind beide ASTs identisch.</code></pre>
<p>Folgerungen.</p>
<ol style="list-style-type: decimal">
<li><p>In der Vergleichsroutine zweier ASTs wird erst normalisiert, z.B. alle Additionen Linksassoziativ dargestellt.</p></li>
<li><p>Anstatt dem AST Vergleich, werden beide ASTs interpretiert (eval). Das Ergebnis muss dann gleich sein.</p></li>
</ol>
</div>
<div id="teilaufgabe-4-semantik" class="slide section level1">
<h1>Teilaufgabe 4: SEMANTIK</h1>
<p>Wir betrachten die semantische Auswertung von Ausdrücken. Dazu gibt es zwei prinzipielle Ansätze.</p>
<p>Interpreter/Interpretation. Das Programm (der AST) wird durchlaufen, und die Ausdrücke ausgewerter. D.h. im Fall vo Addition, werden die Operanden ausgewertet, dann die Addition ausgeführt usw. Ein Interpreter ist Teil der Source files.</p>
<p>Compiler/Compilation. Das Programm (der AST) wird in eine Maschinen-verarbeitbare Form gebracht welche direkt vom Prozessor ausgewertet werden kann. Die Compilation ist ein komplexer Prozess und wird deshalb in eine Reihe von Zwischenschritten (unter Zuhilfenahme von Zwischensprachen) ausgeführt. Z.B. wird der &quot;high-level&quot; AST in einen &quot;low-level&quot; AST umgewandelt, dann dieser in Zwischencode (z.B. nur noch jumps anstatt loops), dann wird der Zwischencode in Assembler umgesetzt usw.</p>
<p>Das Ziel heutzutage ist, dass ein Compiler weitesgehend Plattform-unabhängig ist. Deshalb wird anstatt Assembler/Maschinencode, Code für eine virtuelle Maschine erzeugt (siehe Java/JVM und C#/.Net).</p>
<p>Für unsere sehr einfache Programmiersprache (arithmetische Ausdrücke) betrachten wir eine sehr einfache virtuelle Maschine (VM).</p>
<p>Wir betrachten eine <b>stack-basierte VM</b> in welcher sämtliche Operationen mit Hilfe eines Stacks ausgeführt werden. Der Befehlssatz ist dadurch sehr (sehr) einfach und kann effizient umgesetzt werden. Als populäres Beispiel betrachte man WebAssembly.</p>
<p>Unsere stack-basierte VM verfügt über folgende Instruktionen (Befehle/Codes).</p>
<pre><code>Push i

     schiebe (push) Konstante i auf den Stack

Plus

     hole Operanden von Stack
     fuehre Addition aus
     schiebe Ergebnis aud Stack

Mult

     hole Operanden von Stack
     fuehre Addition aus
     schiebe Ergebnis aud Stack</code></pre>
<p>Ein paar Beispiele, um zu zeigen, wie damit arithmetische Ausdrücke ausgewertet werden können.</p>
<p>Anstatt des ASTs, betrachten wir Ausdrücke in konkreter Syntax. Zuerst der Ausdruck in konkreter Syntax und dann die VM Instruktionen.</p>
<pre><code>1 + 2

Push 1; Push 2; Plus;</code></pre>
<p>Wir betrachten den Stack während der Abarbeitung der VM Instruktionen. Den Stack schreiben wir von links nach rechts. Links = top.</p>
<pre><code>Initial:

Push 1; Push 2, Plus

Stack = []


1. Schritt

Push 2, Plus

Stack = [1]

2. Schritt

Plus

Stack = [1, 2]

3. Schritt


Stack = [3]</code></pre>
<p>Ein komplexeres Beispiel.</p>
<pre><code>1 * (2 + 3)

Push 1; Push 2; Push 3; Plus; Mult;</code></pre>
<p>Die einzelnen Auswertungsschritte.</p>
<pre><code>Initial:

Push 1; Push 2; Push 3; Plus; Mult;

Stack = []

1. Schritt

Push 2; Push 3; Plus; Mult;

Stack = [1]

2. Schritt

Push 3; Plus; Mult;

Stack = [2, 1]

3. Schritt

Plus; Mult;

Stack = [3, 2, 1]

4. Schritt

Mult;

Stack = [5, 1]

5. Schritt

Stack = [5]
</code></pre>
<h3 id="teilaufgabe-semantik">Teilaufgabe SEMANTIK</h3>
<p>Übersetzen Sie den AST in VM Instruktionen. Mehr Hilfestellungen gibt es in der Vorlesung.</p>
<p>Hinweis: Wie können Sie ihre Lösung testen? Vergleich des (finalen) Ergebnis Interpreter und Ausführung VM Instruktionen.</p>
</div>
<div id="source-files-aufgabe-4" class="slide section level1">
<h1>Source Files (Aufgabe 4)</h1>
<p>Makefile ast.h, ast.cpp tokenizer.h, tokenizer.cpp parser.h, parser.cpp vm.h, vm.cpp testParser.cpp testVM.cpp</p>
<h3 id="makefile">Makefile</h3>
<pre><code>CC=g++ --std=c++11
testParser : testParser.o parser.o tokenizer.o ast.o
    $(CC) testParser.o parser.o tokenizer.o ast.o -o testParser
testParser.o: testParser.cpp
    $(CC) -c testParser.cpp

testVM : testVM.o vm.o
    $(CC) testVM.o vm.o -o testVM
testVM.o: testVM.cpp
    $(CC) -c testVM.cpp


ast.o: ast.cpp ast.h
    $(CC) -c ast.cpp
tokenizer.o: tokenizer.cpp tokenizer.h
    $(CC) -c tokenizer.cpp
parser.o: parser.cpp parser.h ast.h tokenizer.h utility.h
    $(CC) -c parser.cpp
vm.o: vm.cpp vm.h
    $(CC) -c vm.cpp</code></pre>
<h3 id="utility">utility</h3>
<h4 id="utility.h">utility.h</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Utility stuff</span>

<span class="ot">#ifndef __UTILITY__</span>
<span class="ot">#define __UTILITY__</span>

<span class="co">// Haskell&#39;s Maybe</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Optional {
  <span class="dt">bool</span> b;
  T val;
<span class="kw">public</span>:
  Optional() : b(<span class="kw">false</span>) {}
  Optional(T v) : val(v), b(<span class="kw">true</span>) {}
  <span class="dt">bool</span> isJust() { <span class="kw">return</span> b; }
  <span class="dt">bool</span> isNothing() { <span class="kw">return</span> !b; }
  T fromJust() { <span class="kw">return</span> val; }
};

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
Optional&lt;T&gt; nothing() {
  <span class="kw">return</span> Optional&lt;T&gt;();
}

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
Optional&lt;T&gt; just(T v) {
  <span class="kw">return</span> Optional&lt;T&gt;(v);
}


<span class="ot">#endif </span><span class="co">// __UTILITY__</span></code></pre></div>
<h3 id="ast">ast</h3>
<h4 id="ast.h">ast.h</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// AST for exp</span>


<span class="ot">#ifndef __AST__</span>
<span class="ot">#define __AST__</span>

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std; 

<span class="kw">class</span> Exp {
<span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">int</span> eval() = <span class="dv">0</span>;
  <span class="kw">virtual</span> string pretty() = <span class="dv">0</span>;
};

<span class="kw">class</span> IntExp : <span class="kw">public</span> Exp {
  <span class="dt">int</span> val;
  <span class="kw">public</span>:
  IntExp(<span class="dt">int</span> _val) { val = _val; }
  <span class="dt">int</span> eval();
  string pretty();
};

<span class="kw">class</span> PlusExp : <span class="kw">public</span> Exp {
  std::shared_ptr&lt;Exp&gt; e1;
  std::shared_ptr&lt;Exp&gt; e2;
  <span class="kw">public</span>:
  PlusExp(std::shared_ptr&lt;Exp&gt; _e1, std::shared_ptr&lt;Exp&gt; _e2) {
      e1 = _e1; e2 = _e2;
  }
  <span class="dt">int</span> eval();
  string pretty();
};


<span class="kw">class</span> MultExp : <span class="kw">public</span> Exp {
  std::shared_ptr&lt;Exp&gt; e1;
  std::shared_ptr&lt;Exp&gt; e2;
  <span class="kw">public</span>:
  MultExp(std::shared_ptr &lt;Exp&gt; _e1, std::shared_ptr&lt;Exp&gt; _e2) {
      e1 = _e1; e2 = _e2;
  }
  <span class="dt">int</span> eval();
  string pretty();
};

<span class="co">// Short-hands</span>

<span class="kw">typedef</span> std::shared_ptr&lt;Exp&gt; EXP;

EXP newInt(<span class="dt">int</span> i);

EXP newPlus(EXP l, EXP r);

EXP newMult(EXP l, EXP r);


<span class="ot">#endif </span><span class="co">// __AST__</span></code></pre></div>
<h4 id="ast.cpp">ast.cpp</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;ast.h&quot;</span>

<span class="dt">int</span> IntExp::eval() { <span class="kw">return</span> val;}

string IntExp::pretty() {
      <span class="kw">return</span> to_string(val);
}

<span class="dt">int</span> PlusExp::eval() { <span class="kw">return</span> e1-&gt;eval() + e2-&gt;eval(); }

string PlusExp::pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(e1-&gt;pretty());
    s.append(<span class="st">&quot;+&quot;</span>);
    s.append(e2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);    
    <span class="kw">return</span> s;
}


<span class="dt">int</span> MultExp::eval() { <span class="kw">return</span> e1-&gt;eval() * e2-&gt;eval(); }

string MultExp::pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(e1-&gt;pretty());
    s.append(<span class="st">&quot;*&quot;</span>);
    s.append(e2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);    
    <span class="kw">return</span> s;
  }

EXP newInt(<span class="dt">int</span> i) {
  <span class="kw">return</span> std::make_shared&lt;IntExp&gt;(i);
}

EXP newPlus(EXP l, EXP r) {
  <span class="kw">return</span> std::make_shared&lt;PlusExp&gt;(l,r);
}

EXP newMult(EXP l, EXP r) {
  <span class="kw">return</span> std::make_shared&lt;MultExp&gt;(l,r);
}</code></pre></div>
<h3 id="tokenizer">tokenizer</h3>
<h4 id="tokenizer.h">tokenizer.h</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Tokenizer for exp</span>


<span class="ot">#ifndef __TOKENIZER__</span>
<span class="ot">#define __TOKENIZER__</span>

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">typedef</span> <span class="kw">enum</span> {
  EOS,           <span class="co">// End of string</span>
  ZERO,
  ONE,
  TWO,
  OPEN,
  CLOSE,
  PLUS,
  MULT
} Token_t;

string showTok(Token_t t);

<span class="co">// Elementary tokenize(r) class</span>
<span class="kw">class</span> Tokenize {
  string s;
  <span class="dt">int</span> pos;
<span class="kw">public</span>:
  Tokenize(string s) {
         <span class="kw">this</span>-&gt;s = s;
     pos = <span class="dv">0</span>;
  }

    <span class="co">// Scan throuh string, letter (symbol) by letter.</span>
  Token_t next();
  vector&lt;Token_t&gt; scan();
  string show();  

};


<span class="co">// Wrapper class, provide the (current) token.</span>
<span class="kw">class</span> Tokenizer : Tokenize {
<span class="kw">public</span>:
  Token_t token;
  Tokenizer(string s) : Tokenize(s) { token = next(); }
  <span class="dt">void</span> nextToken() {
    token = next();
  }
};

<span class="ot">#endif </span><span class="co">// __TOKENIZER__</span></code></pre></div>
<h4 id="tokenizer.cpp">tokenizer.cpp</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;tokenizer.h&quot;</span>


string showTok(Token_t t) {
  <span class="kw">switch</span>(t) {
  <span class="kw">case</span> EOS:   <span class="kw">return</span> <span class="st">&quot;EOS&quot;</span>;
  <span class="kw">case</span> ZERO:  <span class="kw">return</span> <span class="st">&quot;ZERO&quot;</span>;    
  <span class="kw">case</span> ONE:   <span class="kw">return</span> <span class="st">&quot;ONE&quot;</span>;
  <span class="kw">case</span> TWO:   <span class="kw">return</span> <span class="st">&quot;TWO&quot;</span>;      
  <span class="kw">case</span> OPEN:  <span class="kw">return</span> <span class="st">&quot;OPEN&quot;</span>;
  <span class="kw">case</span> CLOSE: <span class="kw">return</span> <span class="st">&quot;CLOSE&quot;</span>;
  <span class="kw">case</span> PLUS:  <span class="kw">return</span> <span class="st">&quot;PLUS&quot;</span>;
  <span class="kw">case</span> MULT:  <span class="kw">return</span> <span class="st">&quot;MULT&quot;</span>;
  }
  <span class="co">// NOTE: The (clang) compiler is able to figure out that</span>
  <span class="co">// along all control-flow paths, a return statement will be reached.</span>
}

Token_t Tokenize::next() {
    <span class="kw">if</span>(s.length() &lt;= pos)
      <span class="kw">return</span> EOS;

    <span class="kw">while</span>(<span class="dv">1</span>) {

       <span class="kw">if</span>(s.length() &lt;= pos)
         <span class="kw">return</span> EOS;
      
       <span class="kw">switch</span>(s[pos]) {
       <span class="kw">case</span> <span class="st">&#39;0&#39;</span>: pos++;
                 <span class="kw">return</span> ZERO;        
       <span class="kw">case</span> <span class="st">&#39;1&#39;</span>: pos++;
                 <span class="kw">return</span> ONE;
       <span class="kw">case</span> <span class="st">&#39;2&#39;</span>: pos++;
                 <span class="kw">return</span> TWO;
       <span class="kw">case</span> <span class="st">&#39;(&#39;</span>: pos++;
                 <span class="kw">return</span> OPEN;
       <span class="kw">case</span> <span class="st">&#39;)&#39;</span>: pos++;
                 <span class="kw">return</span> CLOSE;
       <span class="kw">case</span> <span class="st">&#39;+&#39;</span>: pos++;
                 <span class="kw">return</span> PLUS;
       <span class="kw">case</span> <span class="st">&#39;*&#39;</span>: pos++;
                 <span class="kw">return</span> MULT;         
       <span class="kw">default</span>:  <span class="co">// we simply skip all other symbols !</span>
                 pos++;
             <span class="kw">break</span>;
       }
    }
} <span class="co">// next</span>


vector&lt;Token_t&gt; Tokenize::scan() {
    vector&lt;Token_t&gt; v;
    Token_t t;

    <span class="kw">do</span> {
      t = next();
      v.push_back(t);
    }
    <span class="kw">while</span>(t != EOS);

    <span class="kw">return</span> v;
} <span class="co">// scan</span>


string Tokenize::show() {
    vector&lt;Token_t&gt; v = <span class="kw">this</span>-&gt;scan();
    string s;

    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; v.size(); i++) {
      s += showTok(v[i]);
      <span class="kw">if</span>(i<span class="dv">+1</span> &lt; v.size())
    s += <span class="st">&quot;;&quot;</span> ;         <span class="co">// Add delimiter</span>
    }
    <span class="kw">return</span> s;
} <span class="co">// show</span></code></pre></div>
<h3 id="parser">parser</h3>
<h4 id="parser.h">parser.h</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// (Top-down) Parser for exp</span>

<span class="ot">#ifndef __PARSER__</span>
<span class="ot">#define __PARSER__</span>

<span class="ot">#include &quot;utility.h&quot;</span>
<span class="ot">#include &quot;ast.h&quot;</span>
<span class="ot">#include &quot;tokenizer.h&quot;</span>

<span class="kw">class</span> Parser {
  Tokenizer t;

  <span class="co">// E  ::= T E&#39;</span>
  Optional&lt;EXP&gt; parseE();  

  <span class="co">// E&#39; ::= + T E&#39; | </span>
  Optional&lt;EXP&gt; parseE2(EXP left);

  <span class="co">// T  ::= F T&#39;</span>
  Optional&lt;EXP&gt; parseT();

  <span class="co">// T&#39; ::= * F T&#39; |</span>
  Optional&lt;EXP&gt; parseT2(EXP left);

  <span class="co">// F ::= N | (E)</span>
  Optional&lt;EXP&gt; parseF(); 

  
<span class="kw">public</span>:
  Parser(string s) : t(Tokenizer(s)) { }

  Optional&lt;EXP&gt; parse() {
    Optional&lt;EXP&gt; e= parseE();

    <span class="kw">return</span> e;
  }
};




<span class="ot">#endif </span><span class="co">// __PARSER__</span></code></pre></div>
<h4 id="parser.cpp">parser.cpp</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">

<span class="ot">#include &quot;utility.h&quot;</span>
<span class="ot">#include &quot;ast.h&quot;</span>
<span class="ot">#include &quot;tokenizer.h&quot;</span>
<span class="ot">#include &quot;parser.h&quot;</span>


<span class="co">// E  ::= T E&#39;</span>
Optional&lt;EXP&gt; Parser::parseE() {
    
    Optional&lt;EXP&gt; t = parseT();
    <span class="kw">if</span>(t.isNothing())
      <span class="kw">return</span> t;

    <span class="kw">return</span> parseE2(t.fromJust());
}


<span class="co">// E&#39; ::= + T E&#39; | </span>
Optional&lt;EXP&gt; Parser::parseE2(EXP left) {

    <span class="kw">if</span>(t.token == PLUS) {
        t.nextToken();

    Optional&lt;EXP&gt; right = parseT();
    <span class="kw">if</span>(right.isNothing())
      <span class="kw">return</span> right;

    <span class="kw">return</span> parseE2(newPlus(left, right.fromJust()));
    }
    
    <span class="kw">return</span> just&lt;EXP&gt;(left);
}

 
<span class="co">// T  ::= F T&#39;</span>
Optional&lt;EXP&gt; Parser::parseT() {

    Optional&lt;EXP&gt; f = parseF();
    <span class="kw">if</span>(f.isNothing())
      <span class="kw">return</span> f;

    <span class="kw">return</span> parseT2(f.fromJust());
}


<span class="co">// T&#39; ::= * F T&#39; |</span>
Optional&lt;EXP&gt; Parser::parseT2(EXP left) {
    <span class="kw">if</span>(t.token == MULT) {
      t.nextToken();

      Optional&lt;EXP&gt; right = parseF();
      <span class="kw">if</span>(right.isNothing())
    <span class="kw">return</span> right;

      <span class="kw">return</span> parseT2(newMult(left, right.fromJust()));
    }

    <span class="kw">return</span> just&lt;EXP&gt;(left);
}


<span class="co">// F ::= N | (E)</span>
Optional&lt;EXP&gt; Parser::parseF() {
      <span class="kw">switch</span>(t.token) {
      <span class="kw">case</span> ZERO:
          t.nextToken();
          <span class="kw">return</span> just&lt;EXP&gt;(newInt(<span class="dv">0</span>));
      <span class="kw">case</span> ONE:
          t.nextToken();
          <span class="kw">return</span> just&lt;EXP&gt;(newInt(<span class="dv">1</span>));
      <span class="kw">case</span> TWO:
          t.nextToken();
          <span class="kw">return</span> just&lt;EXP&gt;(newInt(<span class="dv">2</span>));
      <span class="kw">case</span> OPEN: { <span class="co">// introduce new scope</span>
          t.nextToken();
      Optional&lt;EXP&gt; e = parseE();
      <span class="kw">if</span>(e.isNothing())
        <span class="kw">return</span> e;
          <span class="kw">if</span>(t.token != CLOSE)
        <span class="kw">return</span> nothing&lt;EXP&gt;();
      t.nextToken();
      <span class="kw">return</span> e; }
      <span class="kw">default</span>: <span class="kw">return</span> nothing&lt;EXP&gt;();
      }

}</code></pre></div>
<h3 id="vm">vm</h3>
<h4 id="vm.h">vm.h</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Stack-based VM</span>

<span class="ot">#ifndef __VM__</span>
<span class="ot">#define __VM__</span>

<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;stack&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;utility.h&quot;</span>


<span class="co">/*</span>

<span class="co">Stack-based VM, instructions supported are:</span>

<span class="co">  Push i</span>
<span class="co">  Plus</span>
<span class="co">  Mult</span>

<span class="co"> */</span>



<span class="kw">typedef</span> <span class="kw">enum</span> {
  PUSH,
  PLUS,
  MULT

} OpCode_t;


<span class="kw">class</span> Code {
<span class="kw">public</span>:
  OpCode_t kind;
  <span class="dt">int</span> val;

  <span class="co">// Nullary VM code (PLUS, MULT)</span>
  Code(OpCode_t o) : kind(o) {}
  <span class="co">// Unary VM code (Push i)</span>
  Code(OpCode_t o, <span class="dt">int</span> i) : kind(o), val(i) {}
};

<span class="co">// Short-hands</span>

Code newPush(<span class="dt">int</span> i);

Code newPlus();

Code newMult();

<span class="kw">class</span> VM {
    vector&lt;Code&gt; code;
    stack&lt;<span class="dt">int</span>&gt; s;
  <span class="kw">public</span>:
    VM(vector&lt;Code&gt; c) : code(c) {}

    Optional&lt;<span class="dt">int</span>&gt; run();

};
  



<span class="ot">#endif </span><span class="co">// __VM__</span></code></pre></div>
<h4 id="vm.cpp">vm.cpp</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include &quot;utility.h&quot;</span>
<span class="ot">#include &quot;vm.h&quot;</span>


Code newPush(<span class="dt">int</span> i) {
  <span class="kw">return</span> Code(PUSH, i);
}

Code newPlus() {
  <span class="kw">return</span> Code(PLUS);
}

Code newMult() {
  <span class="kw">return</span> Code(MULT);
}


Optional&lt;<span class="dt">int</span>&gt; VM::run() {

      <span class="co">// always start with an empty stack</span>
      stack&lt;<span class="dt">int</span>&gt; d;
      s.swap(d);
      
      <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; code.size(); i++) {
    <span class="kw">switch</span>(code[i].kind) {
    <span class="kw">case</span> PUSH:
      s.push(code[i].val);
        <span class="kw">break</span>; 
    <span class="kw">case</span> MULT: {
      <span class="dt">int</span> right = s.top();
      s.pop();
      <span class="dt">int</span> left = s.top();
      s.pop();
      s.push(left * right);
      <span class="kw">break</span>;  
    }
    <span class="kw">case</span> PLUS: {
      <span class="dt">int</span> right = s.top();
      s.pop();
      <span class="dt">int</span> left = s.top();
      s.pop();
      s.push(left + right);
      <span class="kw">break</span>;  
    }       
    }
      }

      <span class="kw">if</span>(s.empty())
    <span class="kw">return</span> nothing&lt;<span class="dt">int</span>&gt;();

      <span class="kw">return</span> just&lt;<span class="dt">int</span>&gt;(s.top());
} <span class="co">// run</span></code></pre></div>
<h3 id="testparser.cpp">testParser.cpp</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="ot">#include &quot;parser.h&quot;</span>
<span class="ot">#include &quot;ast.h&quot;</span>



<span class="dt">void</span> display(Optional&lt;EXP&gt; e) {
  <span class="kw">if</span>(e.isNothing()) {
    cout &lt;&lt; <span class="st">&quot;nothing </span><span class="ch">\n</span><span class="st">&quot;</span>;
  } <span class="kw">else</span> {
    cout &lt;&lt; (e.fromJust())-&gt;pretty() &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
  }
  <span class="kw">return</span>;
}

<span class="dt">void</span> testParserGood() {

  <span class="co">/*</span>
<span class="co">  display(Parser(&quot;1&quot;).parse());</span>

<span class="co">  display(Parser(&quot;1 + 0 &quot;).parse());</span>

<span class="co">  display(Parser(&quot;1 + (0) &quot;).parse());</span>

<span class="co">  display(Parser(&quot;1 + 2 * 0 &quot;).parse());</span>

<span class="co">  display(Parser(&quot;1 * 2 + 0 &quot;).parse());</span>
<span class="co">  */</span>

  display(Parser(<span class="st">&quot;(1 + 2) * 0 &quot;</span>).parse());

  display(Parser(<span class="st">&quot;(1 + 2) * 0 + 2&quot;</span>).parse());
}

<span class="dt">void</span> testParser() {

  testParserGood();
}


<span class="dt">int</span> main() {

    testParser();
  
  <span class="kw">return</span> <span class="dv">1</span>;
}</code></pre></div>
<h3 id="testvm.cpp">testVM.cpp</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;vm.h&quot;</span>

<span class="dt">void</span> showVMRes(Optional&lt;<span class="dt">int</span>&gt; r) {
  <span class="kw">if</span>(r.isNothing())
    cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">VM stack (top): empty&quot;</span>;

  cout &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">VM stack (top):&quot;</span> &lt;&lt; r.fromJust();
  

}

<span class="dt">void</span> testVM() {

  {
    vector&lt;Code&gt; vc{
          newPush(<span class="dv">1</span>),
      newPush(<span class="dv">2</span>),
      newPush(<span class="dv">3</span>),
      newMult(),
      newPlus() };

    Optional&lt;<span class="dt">int</span>&gt; res = VM(vc).run();

    showVMRes(res);
  }
  
  {
    vector&lt;Code&gt; vc{
          newPush(<span class="dv">2</span>),
      newPush(<span class="dv">3</span>),
      newPush(<span class="dv">5</span>),
      newPlus(),
      newMult() };

    Optional&lt;<span class="dt">int</span>&gt; res = VM(vc).run();

    showVMRes(res);
  }
}


<span class="dt">int</span> main() {

  testVM();
  
  <span class="kw">return</span> <span class="dv">1</span>;
}</code></pre></div>
</div>
</body>
</html>
