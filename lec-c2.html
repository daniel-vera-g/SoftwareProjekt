<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Einführung in C - Teil 2</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Einführung in C - Teil 2</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="inhalt" class="slide section level1">
<h1>Inhalt</h1>
<ul>
<li>Funktionen</li>
<li>Header und Source Files</li>
<li>Präprozessor und Makros</li>
</ul>
</div>
<div id="funktionen" class="slide section level1">
<h1>Funktionen</h1>
<pre><code>int func(int, float)
void func(int, float)
int func()
void func()</code></pre>
<ul>
<li>Parameterliste und Rückgabewerte können <code>void</code> sein</li>
<li>(Einziges) Abstraktionsmittel in C (keine Klassen/Objekte)</li>
<li>Call-by value Argumentenübergabe (kopieren)</li>
<li>Referenzübergabe durch Pointer (später)</li>
<li>Keine Überladung, aber variable Argumentenliste, siehe <code>printf</code></li>
<li>Keine geschachtelteten Funktionsdefinitionen</li>
</ul>
</div>
<div id="funktionen---parameterübergabe" class="slide section level1">
<h1>Funktionen - Parameterübergabe</h1>
<p><b>Beachte</b></p>
<p>In C/C++ <em>immer</em> call-by value (Wertübergabe).</p>
<p>In Java</p>
<ul>
<li><p>call-by value im Fall von primitive Datentypen</p></li>
<li><p>call-by reference im Fall von Objekten komplexer Klassen.</p></li>
</ul>
<h2 id="beispiel-1-call-by-value">Beispiel 1 (call-by value)</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> inc(<span class="dt">int</span> x) {
    x++;
    <span class="kw">return</span> x;
}

<span class="dt">int</span> main() {
   <span class="dt">int</span> y,z;
   y = inc(<span class="dv">3+4</span>);
   z = inc(y);
   <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Die Auswertungsschritte im einzelnen.</p>
<p>Betrachte <code>y = inc(3+4)</code>:</p>
<ol style="list-style-type: decimal">
<li><p>Auswertung Argument <code>3+4</code> liefert <code>7</code>.</p></li>
<li><p>Aufruf <code>inc(7)</code> liefert <code>8</code>.</p></li>
<li><p>Bindung von <code>y</code> an den Wert <code>8</code>.</p></li>
</ol>
<p>Betrachte <code>z = inc(y)</code>:</p>
<ol style="list-style-type: decimal">
<li><p>Auswertung von <code>y</code> liefert Wert <code>8</code>.</p></li>
<li><p>Aufruf von <code>inc(8)</code> liefert Wert <code>9</code>.</p></li>
<li><p>Bindung von <code>z</code> an den Wert <code>9</code>.</p></li>
</ol>
<h2 id="beispiel-2-call-by-value">Beispiel 2 (call-by value)</h2>
<p><em>Strukturen</em> (= &quot;public classes&quot;) werden formal erst nachher besprochen.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> position {
  <span class="dt">int</span> x;
  <span class="dt">float</span> y;
};

<span class="dt">void</span> f(<span class="kw">struct</span> position p) {
   p.x++;
   <span class="co">// p.x == 2</span>
}

<span class="dt">int</span> main () { 
  <span class="kw">struct</span> position q;
  q.x = <span class="dv">1</span>;
  q.y = <span class="fl">2.0</span>;

  f(q);
  <span class="co">// q.x == 1</span>

 <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Betrachte <code>f(q)</code>:</p>
<ol style="list-style-type: decimal">
<li><p>Aufruf von Funktion <code>f</code>. Bindung von formalen Parameter an die Werte von <code>q</code>.</p></li>
<li><p>Innerhalb von <code>f</code>, inkrementiere x Position.</p></li>
<li><p>Nach Rücksprung aus <code>f</code>, Werte von <code>q</code> sind unverändert!</p></li>
</ol>
<h2 id="vergleich-zu-java">Vergleich zu Java</h2>
<p>Gleiches Verhalten im Falle von Beispiel 1 (da primitiver Datentyp <code>int</code>).</p>
<p>Unterschied im Fall von Beispiel 2. In Java, call-by reference im Fall von Objekten komplexer Klassen. Struktur <code>position</code> ist eine komplexe &quot;public class&quot;.</p>
<p>Deshalb in Java. Nach Rücksprung aus <code>f</code> gilt: <code>q.x == 2</code>!</p>
<h2 id="fazit">Fazit</h2>
<p>In C/C++ <em>immer</em> call-by value (Wertübergabe).</p>
<p>Call-by reference kann durch Zeiger emuliert werden.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> f2(<span class="kw">struct</span> position* p) {
   (*p).x++;
}

<span class="dt">int</span> main () { 
  <span class="kw">struct</span> position q;
  q.x = <span class="dv">1</span>;
  q.y = <span class="fl">2.0</span>;

  f2(&amp;q);
 <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<ul>
<li><p>Funktion <code>f2</code> erwartet ein Zeigerargument.</p></li>
<li><p>Zugriff via Zeiger auf Wert via Dereferenzierung <code>*p</code>.</p></li>
<li><p>Aufruf von <code>f2</code>: Berechnung der Adresse von <code>p</code> via <code>&amp;p</code>.</p></li>
</ul>
<p>In C++ gibt es eine &quot;direktere&quot; Notation für call-by reference.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> f3(<span class="kw">struct</span> position &amp;p) {
   p.x++;
}

<span class="dt">int</span> main () { 
  <span class="kw">struct</span> position q;
  q.x = <span class="dv">1</span>;
  q.y = <span class="fl">2.0</span>;

  f3(q);
 <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<ul>
<li><p>Parameter deklariert als call-by reference, siehe <code>void f3(struct position &amp;p)</code></p></li>
<li><p>Keine Berechnung der Adresse bei Aufruf notwendig.</p></li>
<li><p>Effektiv wird call-by reference durch Zeiger implementiert.</p></li>
</ul>
</div>
<div id="mehrere-funktionen-deklaration-versus-definition" class="slide section level1">
<h1>Mehrere Funktionen (Deklaration versus Definition)</h1>
<ul>
<li>Guter Stil, Angabe des Funktionsprototypen</li>
<li>Im Falle von sich gegenseitig aufrufenden Funktionen notwendig</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Deklaration, Vorwärtsreferenz</span>
<span class="dt">int</span> f(<span class="dt">int</span>);
<span class="dt">int</span> g(<span class="dt">int</span>);

<span class="co">// Definition</span>
<span class="dt">int</span> f(<span class="dt">int</span> x) {
  <span class="kw">if</span>(x==<span class="dv">1</span>) <span class="kw">return</span> g(x);
  <span class="kw">return</span> <span class="dv">1</span>;
}

<span class="dt">int</span> g(<span class="dt">int</span> y) {
  <span class="kw">if</span>(y==<span class="dv">0</span>) <span class="kw">return</span> f(y<span class="dv">+1</span>);
  <span class="kw">return</span> <span class="dv">2</span>;
}</code></pre></div>
</div>
<div id="funktionen-und-statische-variablen" class="slide section level1">
<h1>Funktionen und statische Variablen</h1>
<ul>
<li>Funktionen haben Zugriff auf globale Variablen und ihre aktuellen lokalen Variablen auf dem Stack.</li>
<li>Nach verlassen der Funktion werden die lokalen Variablen vom Stack gelöscht.</li>
<li>Ausnahme: Statisch deklarierte lokale Variablen
<ul>
<li>Eine Instanz auch bei mehreren Funktionsaufrufen</li>
<li>Lebenszeit solange bis Hauptprogramm terminiert wird.</li>
</ul></li>
</ul>
</div>
<div id="funktionen-und-statische-variablen-am-beispiel" class="slide section level1">
<h1>Funktionen und statische Variablen am Beispiel</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> count(<span class="dt">void</span>) {
  <span class="dt">static</span> <span class="dt">int</span> i = <span class="dv">0</span>; <span class="co">// statische Variable</span>
  i++;
  <span class="kw">return</span> i;
}

<span class="dt">int</span> main () {
  printf(<span class="st">&quot;Aufruf Nr. %d </span><span class="ch">\n</span><span class="st">&quot;</span>, count());
  printf(<span class="st">&quot;Aufruf Nr. %d </span><span class="ch">\n</span><span class="st">&quot;</span>, count());
  printf(<span class="st">&quot;Aufruf Nr. %d </span><span class="ch">\n</span><span class="st">&quot;</span>, count());
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<ul>
<li>Ausgabe?</li>
</ul>
</div>
<div id="funktionsbezeichner-function-qualifier" class="slide section level1">
<h1>Funktionsbezeichner (&quot;Function Qualifier&quot;)</h1>
<p>Funktionsbezeichner: <code>static</code>, <code>extern</code>, <code>inline</code></p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">static</span> <span class="dt">void</span> f(<span class="dt">void</span>) {}
<span class="kw">extern</span> <span class="dt">void</span> f(<span class="dt">void</span>); 
<span class="kw">inline</span> <span class="dt">void</span> g(<span class="dt">void</span>) {}</code></pre></div>
<ul>
<li><p><code>static</code> nur sichtbar im gleichen File</p></li>
<li><code>extern</code> ausserhalb durch Verbindung durch Linker
<ul>
<li>In der Regel redundant</li>
<li>Sinnvoll falls nicht im Header aufgeführt</li>
</ul></li>
<li><p><code>inline</code> Ersetzung Funktionsaufruf durch Funktionsrumpf</p></li>
</ul>
</div>
<div id="header-und-source-files" class="slide section level1">
<h1>Header und Source Files</h1>
<ul>
<li>Bisher ein File, nicht realisitisch für grössere Projekte</li>
<li>Aber: C hat kein Modulkonzept</li>
<li>Konvention:
<ul>
<li>Deklaration (Schnittstelle) in Header File (.h)</li>
<li>Definition (Implementierung) in Source File (.c)</li>
</ul></li>
<li>cygwin:
<ul>
<li>Kompilierung der .c Files <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> .o Objekt Files</li>
<li>Linker baut &quot;main&quot;</li>
<li>Im Regelfall Abhängigkeiten definiert durch ein makeFile</li>
</ul></li>
<li>Visual Studio:
<ul>
<li>Ablegen in jeweilige Ordner</li>
<li>Automatischer &quot;build&quot; Prozess</li>
</ul></li>
</ul>
</div>
<div id="header-und-source-beispiel" class="slide section level1">
<h1>Header und Source Beispiel</h1>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// fact.h Header mit Funktions-prototyp</span>
<span class="dt">unsigned</span> <span class="dt">int</span> fact(<span class="dt">unsigned</span> <span class="dt">int</span> n);</code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// fact.c Source</span>
<span class="ot">#include &quot;fact.h&quot;</span>
<span class="dt">unsigned</span> <span class="dt">int</span> fact(<span class="dt">unsigned</span> <span class="dt">int</span> n) {
  <span class="kw">return</span> n ? n*fact(n<span class="dv">-1</span>) : <span class="dv">1</span>;  
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// fact_main.c Anwendung</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &quot;fact.h&quot;</span>

<span class="dt">int</span> main () {
  printf(<span class="st">&quot;fact(3)=%d </span><span class="ch">\n</span><span class="st">&quot;</span>, fact(<span class="dv">3</span>));
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
</div>
<div id="separate-kompilierung-und-linken" class="slide section level1">
<h1>Separate Kompilierung und Linken</h1>
<ul>
<li>Kompiliere <code>fact.c</code></li>
</ul>
<pre><code>$gcc.exe -c fact.c -o fact.o</code></pre>
<ul>
<li>Kompiliere <code>fact_main.c</code>, linke dazu <code>fact.o</code></li>
</ul>
<pre><code>$gcc.exe fact.o fact_main.c</code></pre>
<ul>
<li>Dieser ``make'' Prozess wird normalerweise automatisiert</li>
</ul>
</div>
<div id="make" class="slide section level1">
<h1>make</h1>
<ul>
<li>Regel-basiert</li>
</ul>
<pre><code>    Ziel : Quellen
           Aktion</code></pre>
<ul>
<li>Beispiel <code>Makefile</code>:</li>
</ul>
<pre><code>CC=gcc.exe
fact_main.exe : fact_main.o fact.o
                $(CC) fact.o fact_main.o -o fact_main.exe
fact_main.o: fact_main.c
                $(CC) -c fact_main.c
fact.o: fact.c fact.h
                $(CC) -c fact.c</code></pre>
<ul>
<li><code>make Makefile</code>
<ul>
<li>Automatische Ausführung falls sich Quellen ändern</li>
</ul></li>
<li><a href="http://www.delorie.com/djgpp/doc/ug/larger/makefiles.html" class="uri">http://www.delorie.com/djgpp/doc/ug/larger/makefiles.html</a></li>
</ul>
</div>
<div id="präprozessor-und-makros" class="slide section level1">
<h1>Präprozessor und Makros</h1>
<ul>
<li>Vor Kompilierung: Präprozessor und auflösen von Makros</li>
<li>Effektiv ist der Präprozessor ein Textmanipulationsprogramm.</li>
<li>Präprozessor Direktive/Befehle am Anfang einer Zeile, Start mit <code>#</code></li>
<li>Ersetzungsbefehle</li>
</ul>
<pre><code>      #include and #define</code></pre>
<ul>
<li>Bedingte/Konditionale Befehle</li>
</ul>
<pre><code>      #if, #elif, #else and #endif</code></pre>
</div>
<div id="include" class="slide section level1">
<h1><code>#include</code></h1>
<ul>
<li>Zwei Formen</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &quot;filename&quot; </span>
<span class="ot">#include &lt;filename&gt;</span></code></pre></div>
<ul>
<li>Beide Formen ersetzen <code>#include ...</code> mit dem Inhalt von filename.</li>
<li>Quote <code>&quot;...&quot;</code> startet Suche von der aktuellen (directory) Position.</li>
<li><code>&lt;...&gt;</code> durchsucht erst vorgegebene Ordner.</li>
<li>Wenn ein include File sich ändert, sollten alle abhängigen Files neu kompiliert werden.</li>
</ul>
</div>
<div id="define" class="slide section level1">
<h1><code>#define</code></h1>
<ul>
<li>Form</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define Name Ersetzung</span></code></pre></div>
<ul>
<li><p>Definition von Macros</p></li>
<li><p>Beispiele</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define PI 3.141592654</span>
<span class="ot">#define MAX(A,B) ((A)&gt;(B)?(A):(B))</span></code></pre></div>
<ul>
<li>Beachte define Macros dürfen Parameter haben. Mächtige Meta-Sprache.</li>
<li>Ersetzung muss innerhalb einer Zeile sein.</li>
</ul>
</div>
<div id="konditionale-präprozessor-befehle" class="slide section level1">
<h1>Konditionale Präprozessor Befehle</h1>
<p>Zwei Standardbeispiele</p>
<ul>
<li>Konditionale Kompilierung</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#if SYSTEM_SYSV</span>
<span class="ot">#define HDR &quot;sysv.h&quot;</span>
<span class="ot">#elif SYSTEM_BSD</span>
<span class="ot">#define HDR &quot;bsd.h&quot;</span>
<span class="ot">#else</span>
<span class="ot">#define HDR &quot;default.h&quot; </span>
<span class="ot">#endif</span>
<span class="ot">#include HDR</span></code></pre></div>
<ul>
<li>Aufbrechen von Zyklen bei rekursiven Imports</li>
</ul>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#ifndef __SOMEHEADER__</span>
<span class="ot">#define __SOMEHEADER__ 1</span>
... <span class="co">// Header: Deklarationen und defines</span>
<span class="ot">#endif  </span></code></pre></div>
</div>
<div id="standardbibliotheken" class="slide section level1">
<h1>Standardbibliotheken</h1>
<ul>
<li>Standard Hilfsfunktionen <code>#include &lt;stdlib.h&gt;</code></li>
</ul>
<p><a href="http://www.cplusplus.com/reference/clibrary/cstdlib/" class="uri">http://www.cplusplus.com/reference/clibrary/cstdlib/</a></p>
<ul>
<li>Character Funktionen <code>#include &lt;ctype.h&gt;</code></li>
</ul>
<p><a href="http://www.cplusplus.com/reference/clibrary/cctype/" class="uri">http://www.cplusplus.com/reference/clibrary/cctype/</a></p>
<ul>
<li>String Manipulationen <code>#include &lt;string.h&gt;</code></li>
</ul>
<p><a href="http://www.cplusplus.com/reference/clibrary/cstring/" class="uri">http://www.cplusplus.com/reference/clibrary/cstring/</a></p>
</div>
<div id="zusammenfassung" class="slide section level1">
<h1>Zusammenfassung</h1>
<ul>
<li>Funktionen</li>
<li>Funktions-/Typbezeichner</li>
<li>Header und Source Files</li>
<li>Präprozessor und Makros</li>
</ul>
</div>
</body>
</html>
