<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Dynamische Analyse/Testen</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Dynamische Analyse/Testen</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="dynamische-analysetesten" class="slide section level1">
<h1>Dynamische Analyse/Testen</h1>
<p><em>Analyse des Programmverhaltens zur Laufzeit.</em></p>
<p>Beispiele:</p>
<ul>
<li>Kein Nullpointer Zugriff</li>
<li>Zu jedem lock ein unlock</li>
<li>Data races</li>
<li>Online Auktion: Verkaufe falls der Preis um 2% fällt innerhalb von 2 Tagen.</li>
<li>...</li>
</ul>
<p>Naive Ansätze:</p>
<p>Teil des Programmcodes (instrumentiert durch SW-Entwickler):</p>
<ul>
<li>assert</li>
<li>print</li>
</ul>
<p>Schwer wartbar. Alles abgedeckt...</p>
<p>Wir betrachten:</p>
<ul>
<li><p>Aufbau von Tests (stimuliere, messe und überprüfe)</p></li>
<li><p>Beispiele, ...</p></li>
<li><p>Semi-automatische Testgenerierung mit Hilfe von QuickCheck am Beispiel von &quot;count&quot; und &quot;regulären Ausdrücken&quot;</p></li>
<li><p>Aufzeichung und Validierung von Programmspuren (&quot;traces&quot;)</p></li>
</ul>
</div>
<div id="dynamische-analyse---stimuliere-messe-und-überprüfe" class="slide section level1">
<h1>Dynamische Analyse - Stimuliere, messe und überprüfe</h1>
<ol style="list-style-type: decimal">
<li><p>Ausführung des Programm Codes (Stimulation)</p></li>
<li><p>Aufzeichung/Messung Programmverhaltens</p></li>
<li><p>Überprüfung/Validation auf (Fehl)verhalten</p></li>
</ol>
<p>Basierend auf obiger Aufteiltung, ein Test setzt sich zusammen aus:</p>
<ol style="list-style-type: decimal">
<li><p><em>Testfall</em> (INPUT) zur Ausführung des Programm Codes (z.B. Setzen von Inputs, Methodenaufruf, ...)</p></li>
<li><p><em>Testaufzeichnung</em> (OUTPUT) zur Beobachtung des Programmverhaltens</p></li>
<li><p><em>Testorakel</em> um zu entscheiden, ob beobachtetes Programmverhalten korrekt ist. D.h. der unter INPUT erhaltene OUTPUT wird gegen EXPECTED( ERWARTETE ERGEBNIS) verglichen.</p></li>
</ol>
<p>Teststufen: Unit Test, Modul Test, ..., System Test</p>
<h2 id="quickcheck-ansatz">QuickCheck Ansatz</h2>
<p><a href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a></p>
<ol style="list-style-type: decimal">
<li><p>Definiere erwartete Eigentschaft/Verhalten (&quot;PROPERTY&quot;) in einer high-level Sprache (&quot;modell-basiert&quot;)</p></li>
<li><p>Definiere Generatoren zur automatischen Generierung von Testfällen (INPUT)</p></li>
<li><p>Messe OUTPUT</p></li>
<li><p>PROPERTY entscheidet, ob OUTPUT korrekt ist.</p></li>
</ol>
<h2 id="vergleich-unit-test-vs-quickcheck">Vergleich Unit-Test vs QuickCheck</h2>
<p>Als Beispiel betrachten wir die <code>reverse</code> Funktion. Eingabe/Ausgabe (INPUT/OUTPUT) sind Listen, z.B. [], [1,2], ...</p>
<h3 id="unit-test">Unit-Test</h3>
<p>Liste von Paaren (INPUT, OUTPUT):</p>
<pre><code>[  ([], []),
   ([1], [1]),
   ([1,2], [2,1]),
   ([1,4,5], [5,4,1])
]</code></pre>
<h3 id="quickcheck">QuickCheck</h3>
<pre><code>prop xs = reverse(reverse(xs)) == xs</code></pre>
<p>Details zur automatischen Generierung von Testfälle siehe unten</p>
<p>Beachte: Die Property <code>prop</code> nur eine notwendige aber nicht hinreichende Bedingung, um zu garantieren, dass die <code>reverse</code> Funktion korrekt ist.</p>
<h3 id="programmverifikation">Programmverifikation</h3>
<pre><code>reverse([]) == []

Fuer alle Listen xs muss gelten:

reverse(x:xs) = x : reverse(xs)</code></pre>
</div>
<div id="beispiele-softwareprojekt" class="slide section level1">
<h1>Beispiele Softwareprojekt</h1>
<p>Siehe Invariante (Property) im Fall von int16 switchLowHighByte(int16).</p>
<p>Testrahmen für &quot;count&quot;.</p>
<h2 id="spezifikation-und-ableitung-von-unit-testfällen-count">Spezifikation und Ableitung von (Unit) Testfällen (&quot;count&quot;)</h2>
<p>&quot;Recall&quot;:</p>
<p>Ein Wort ist eine Sequenz von Zeichen in der das Leerzeichen (white-space) nicht vorkommt. Funktion <code>count</code> zählt die Anzahl der Wörter in einem String .</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  TestCase tests[<span class="dv">9</span>] = { 
       {<span class="st">&quot;&quot;</span>, <span class="dv">0</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;Hallo&quot;</span>, <span class="dv">1</span>},
       {<span class="st">&quot;  Hallo  &quot;</span>, <span class="dv">1</span>},              

       {<span class="st">&quot;Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo&quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot;Hal lo &quot;</span>, <span class="dv">2</span>},  
       {<span class="st">&quot; Hal lo  &quot;</span>, <span class="dv">2</span>}              
     };</code></pre></div>
<ul>
<li>Tests so elementar wie möglich.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">       {<span class="st">&quot;Super long Test    &quot;</span>, <span class="dv">3</span>},  </code></pre></div>
<p>Kann sinnvoll sein. Aber, je &quot;kleiner&quot; der Test, desto einfacher den Bug zu finden (im allgemeinen).</p>
<ul>
<li>Fehlerhafte Tests</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">       {<span class="st">&quot;Bug gy Test    &quot;</span>, <span class="dv">2</span>},  </code></pre></div>
<p>Tests müssen validiert werden</p>
<ul>
<li>Durch Tests werden &quot;versteckte&quot; Annahmen deutlich</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">       {<span class="st">&quot;   Wort1    Wort2    &quot;</span>, <span class="dv">2</span>},  </code></pre></div>
<p>Wörter durch mehrere Leerzeichen getrennt.</p>
<ul>
<li><p>Ausreichende Anzahl von Tests?</p>
<ul>
<li>Semi-formale Spezifikation
<ul>
<li>Grauzone</li>
<li>Expertenwissen notwendig, um zu entscheiden ob Test notwendig und korrekt</li>
</ul></li>
<li>Formale Spezifikation
<ul>
<li>Testausführung oft direkt automatisierbar</li>
<li>Ableitung von Testfällen oft automatisch</li>
</ul></li>
</ul></li>
<li>Generierung zufälliger Tests
<ul>
<li><code>brute-force</code> Methode</li>
<li>Effektiv in der Praxis ('odd cases')</li>
</ul></li>
</ul>
<h2 id="generierung-zufälliger-tests">Generierung zufälliger Tests</h2>
<ul>
<li><p>Generatoren (aufgeteilt nach TYPEN)</p>
<ul>
<li>Buchstaben (letters) - ATOMIC</li>
<li>Wörter (words) - LISTS</li>
<li>Leerzeichen (blanks) - LISTS</li>
<li>Strings (sequences of words and blanks) - ALTERNATION</li>
</ul></li>
<li><p>Something quick and dirty in Haskell</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">{-# LANGUAGE ScopedTypeVariables  #-}</span>

<span class="co">-- generation of random &#39;count&#39; Tests</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">System.Random</span>


<span class="co">-- helpers</span>

<span class="co">-- | map integer n to the range [0..rng]</span>
range n rng <span class="fu">=</span> (abs n) <span class="ot">`mod`</span> rng


<span class="co">-- letters in a word</span>
letters <span class="fu">=</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;0&#39;</span><span class="fu">..</span><span class="ch">&#39;9&#39;</span>]


<span class="co">-- | Generate random letter</span>
<span class="ot">genLetter ::</span> <span class="dt">IO</span> <span class="dt">Char</span>
genLetter <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
               <span class="kw">let</span> c <span class="fu">=</span> letters <span class="fu">!!</span> (range i (length letters <span class="fu">-</span> <span class="dv">1</span>))
               return c

<span class="co">-- | Generate random word with at most six letters</span>
<span class="ot">genWord ::</span> <span class="dt">IO</span> <span class="dt">String</span>
genWord <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
             ls <span class="ot">&lt;-</span> mapM (\_ <span class="ot">-&gt;</span> genLetter) [<span class="dv">0</span><span class="fu">..</span> (range i <span class="dv">6</span>)]
             return ls

<span class="co">-- | Generate random number of blanks, at most five</span>
<span class="ot">genBlanks ::</span> <span class="dt">IO</span> <span class="dt">String</span>
genBlanks <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
               return <span class="fu">$</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> replicate (range i <span class="dv">4</span>) <span class="ch">&#39; &#39;</span>

<span class="co">-- | Generate random test, max 15 words in a string</span>
<span class="ot">genTest ::</span> <span class="dt">IO</span> (<span class="dt">String</span>,<span class="dt">Int</span>)
genTest <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
             <span class="kw">let</span> n <span class="fu">=</span> range i <span class="dv">15</span> 
             <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">0</span>
              <span class="kw">then</span> return (<span class="st">&quot;&quot;</span>,<span class="dv">0</span>)
              <span class="kw">else</span> <span class="kw">do</span> ws <span class="ot">&lt;-</span> mapM (\_ <span class="ot">-&gt;</span> <span class="kw">do</span> ls <span class="ot">&lt;-</span> genWord
                                           bs <span class="ot">&lt;-</span> genBlanks
                                           return (ls <span class="fu">++</span> bs))
                                 [<span class="dv">1</span><span class="fu">..</span>n]
             
                      return (concat ws, n)


<span class="ot">showTest ::</span> (<span class="dt">String</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">String</span>
showTest (str,n) <span class="fu">=</span> <span class="st">&quot;   {&quot;</span> <span class="fu">++</span> show str <span class="fu">++</span> <span class="st">&quot;,&quot;</span><span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot;}&quot;</span>

<span class="co">-- | Random test generation, n test cases</span>
<span class="ot">genTests ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
genTests n <span class="fu">=</span> <span class="kw">do</span> tests <span class="ot">&lt;-</span> mapM (\_ <span class="ot">-&gt;</span> genTest) [<span class="dv">1</span><span class="fu">..</span>n]
                <span class="kw">let</span> testCases <span class="fu">=</span> 
                          foldl (\a <span class="ot">-&gt;</span> \(str,no) <span class="ot">-&gt;</span> 
                                    <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> showTest (str,no) <span class="fu">++</span> <span class="st">&quot;,&quot;</span> <span class="fu">++</span> a)
                                 (<span class="st">&quot;\n&quot;</span> <span class="fu">++</span> showTest (head tests))
                                 (tail tests)
                return <span class="fu">$</span>  <span class="st">&quot;TestCase tests[&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot;] = {&quot;</span> 
                           <span class="fu">++</span>  testCases
                           <span class="fu">++</span> <span class="st">&quot;\n };\n&quot;</span>


printTests n <span class="fu">=</span> <span class="kw">do</span> t <span class="ot">&lt;-</span> genTests n
                  putStrLn t</code></pre></div>
<ul>
<li>Beispiel</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> printTests <span class="dv">3</span>            
<span class="dt">TestCase</span> tests[<span class="dv">3</span>] <span class="fu">=</span> {
   {<span class="st">&quot;ogAXd7    8Zb    d5xuJ   n6K    JRTqw  tC  &quot;</span>,<span class="dv">6</span>},
   {<span class="st">&quot;baynGC   YxGeWk    hpf    k   IqNe  mLwP RHRgF 5c    q  NG    Qq3P  &quot;</span>,<span class="dv">11</span>},
   {<span class="st">&quot;2N   41   C  5JZ &quot;</span>,<span class="dv">4</span>}
 };</code></pre></div>
<ul>
<li>Werden sämtlichen Fälle (zufällig) abgedeckt?
<ul>
<li>Nein</li>
<li>Fall String endet mit Wort wird nie erreicht (immer mindestens ein Leerzeichen am Schluss)</li>
</ul></li>
<li>Diversitärer Ansatz
<ul>
<li>Generierung Testfälle und Beschreibung Testorakel in einer anderen Programmiersprache (anderer Entwickler)</li>
<li>Vermeidet dass die gleichen Fehler gemacht werden</li>
</ul></li>
</ul>
</div>
<div id="generierung-zufälliger-tests---quickcheck-style" class="slide section level1">
<h1>Generierung zufälliger Tests - QuickCheck Style</h1>
<ul>
<li>QuickCheck: <code>http://en.wikipedia.org/wiki/QuickCheck</code>
<ul>
<li>Ursprünglich für Haskell</li>
<li>So ziemlich für jede Programmiersprache verfügbar</li>
</ul></li>
<li>Bibliothek zur automatischen Generierung von Testfällen</li>
<li>Properties werden in Haskell spezifiziert</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quickCheck ::</span> forall a<span class="fu">.</span> <span class="dt">Gen</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
quickCheck prop <span class="fu">=</span> <span class="kw">do</span>
      tests <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> [a])
      return <span class="fu">$</span> and <span class="fu">$</span> map prop tests</code></pre></div>
<ul>
<li>Generator liefert zufälligen Testfall</li>
<li>Definition von <code>gen</code> überladen</li>
<li>Generiere Liste zufälliger Länge</li>
<li>Für jeden Testfall überprüfe Eigenschaft <code>prop</code></li>
</ul>
<p>Unser Beispiel (in Haskell).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | count in Haskell</span>
count [] <span class="fu">=</span> <span class="dv">0</span>
count (c<span class="fu">:</span>cs)
  <span class="fu">|</span> c <span class="fu">==</span> <span class="ch">&#39; &#39;</span> <span class="fu">=</span> count <span class="fu">$</span> skipBlanks cs
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> count (moveToEnd cs)


moveToEnd [] <span class="fu">=</span> []
moveToEnd (c<span class="fu">:</span>cs)
  <span class="fu">|</span> c <span class="fu">/=</span> <span class="ch">&#39; &#39;</span>  <span class="fu">=</span> moveToEnd cs
  <span class="fu">|</span> otherwise <span class="fu">=</span> c<span class="fu">:</span>cs

skipBlanks [] <span class="fu">=</span> []
skipBlanks (c<span class="fu">:</span>cs) 
  <span class="fu">|</span> c <span class="fu">==</span> <span class="ch">&#39; &#39;</span>  <span class="fu">=</span> skipBlanks cs
  <span class="fu">|</span> otherwise <span class="fu">=</span> c<span class="fu">:</span>cs </code></pre></div>
<p>Die Testeigenschaft.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">prop testCase <span class="fu">=</span> <span class="kw">let</span> str <span class="fu">=</span> unMyString testCase
                <span class="kw">in</span> count str <span class="fu">==</span> length (words str)

<span class="kw">newtype</span> <span class="dt">MyString</span> <span class="fu">=</span> <span class="dt">MyString</span> <span class="dt">String</span>
unMyString (<span class="dt">MyString</span> s) <span class="fu">=</span> s</code></pre></div>
<p>Definition eines eigenen String Typs. String sind universell. Wir betrachten hier aber spezielle Strings (words separated by blanks).</p>
<h2 id="generatoren-gen---schnittstelle-und-kombinatoren">Generatoren (<code>gen</code>) - Schnittstelle und Kombinatoren</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Generic interface</span>
<span class="kw">class</span> <span class="dt">Gen</span> a <span class="kw">where</span>
<span class="ot">   gen ::</span> <span class="dt">IO</span> a</code></pre></div>
<ul>
<li>Generisches Interface</li>
<li>Spezifikation von Typspezifischen Generatoren (durch Überladung)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Some generic combinators</span>

<span class="co">-- | Fixed number</span>
<span class="ot">vector ::</span>  <span class="dt">Gen</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]
vector <span class="dv">0</span> <span class="fu">=</span> return []
vector n
    <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">0</span>  <span class="fu">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> gen
                  xs <span class="ot">&lt;-</span> vector (n<span class="fu">-</span><span class="dv">1</span>)
                  return (x<span class="fu">:</span>xs)
    <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;impossible&quot;</span>


<span class="co">-- | Random number.</span>
<span class="co">-- In practice, we should make it user configurable to choose</span>
<span class="co">-- the max number of list elements.</span>
<span class="kw">instance</span> <span class="dt">Gen</span> a <span class="ot">=&gt;</span> <span class="dt">Gen</span> [a] <span class="kw">where</span>
   gen <span class="fu">=</span> vector <span class="dv">5</span>


<span class="co">-- | Either one or the other</span>
<span class="kw">instance</span> (<span class="dt">Gen</span> a, <span class="dt">Gen</span> b) <span class="ot">=&gt;</span> <span class="dt">Gen</span> (<span class="dt">Either</span> a b) <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">b ::</span> <span class="dt">Bool</span>) <span class="ot">&lt;-</span> randomIO
            <span class="kw">if</span> b 
             <span class="kw">then</span> <span class="kw">do</span> l <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> a)
                     return <span class="fu">$</span> <span class="dt">Left</span> l
             <span class="kw">else</span> <span class="kw">do</span> r <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> b)
                     return <span class="fu">$</span> <span class="dt">Right</span> r</code></pre></div>
<ul>
<li>Hier: Überladung mit Hilfe von Typklassen</li>
<li>Viele weitere Strategien denkbar</li>
<li>Siehe QuickCheck Bibliothek der Lieblingsprogrammiersprache</li>
</ul>
<h2 id="generatoren-gen---spezialfälle-benutzerdefinierbar">Generatoren (<code>gen</code>) - Spezialfälle Benutzerdefinierbar</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">------------------------------------------</span>
<span class="co">-- Abstract description of input data</span>

<span class="kw">data</span> <span class="dt">Str</span> <span class="fu">=</span> <span class="dt">MkStr</span> [<span class="dt">Either</span> <span class="dt">Word</span> <span class="dt">Blanks</span>]

<span class="kw">data</span> <span class="dt">Word</span> <span class="fu">=</span> <span class="dt">MkWord</span> [<span class="dt">Letter</span>]

<span class="kw">data</span> <span class="dt">Blanks</span> <span class="fu">=</span> <span class="dt">MkBlanks</span> [<span class="dt">Char</span>]

<span class="kw">data</span> <span class="dt">Letter</span> <span class="fu">=</span> <span class="dt">MkLetter</span> <span class="dt">Char</span>

<span class="co">-- | map integer n to the range [0..rng]</span>
range<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
range n rng <span class="fu">=</span> (abs n) <span class="ot">`mod`</span> rng

<span class="kw">instance</span> <span class="dt">Gen</span> <span class="dt">Letter</span> <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
            <span class="kw">let</span> c <span class="fu">=</span> letters <span class="fu">!!</span> (range i (length letters <span class="fu">-</span> <span class="dv">1</span>))
            return <span class="fu">$</span> <span class="dt">MkLetter</span> c

         <span class="kw">where</span>
<span class="ot">           letters ::</span> [<span class="dt">Char</span>]
           letters <span class="fu">=</span> [<span class="ch">&#39;a&#39;</span><span class="fu">..</span><span class="ch">&#39;z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;A&#39;</span><span class="fu">..</span><span class="ch">&#39;Z&#39;</span>] <span class="fu">++</span> [<span class="ch">&#39;0&#39;</span><span class="fu">..</span><span class="ch">&#39;9&#39;</span>]


<span class="kw">instance</span> <span class="dt">Gen</span> <span class="dt">Blanks</span> <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> (<span class="ot">i ::</span> <span class="dt">Int</span>) <span class="ot">&lt;-</span> randomIO
            <span class="kw">let</span> n <span class="fu">=</span> range (abs i) <span class="dv">4</span>                   <span class="co">-- max of four blanks</span>
            return <span class="fu">$</span> <span class="dt">MkBlanks</span> <span class="fu">$</span> replicate n <span class="ch">&#39; &#39;</span>

<span class="kw">instance</span> <span class="dt">Gen</span> <span class="dt">Word</span> <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> ls <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> [<span class="dt">Letter</span>])
            return <span class="fu">$</span> <span class="dt">MkWord</span> ls

<span class="kw">instance</span> <span class="dt">Gen</span> <span class="dt">Str</span> <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> os <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> [<span class="dt">Either</span> <span class="dt">Word</span> <span class="dt">Blanks</span>]) 
            return <span class="fu">$</span> <span class="dt">MkStr</span> os

<span class="kw">instance</span> <span class="dt">Gen</span> <span class="dt">MyString</span> <span class="kw">where</span>
   gen <span class="fu">=</span> <span class="kw">do</span> str <span class="ot">&lt;-</span> (<span class="ot">gen ::</span> <span class="dt">IO</span> <span class="dt">Str</span>)
            return <span class="fu">$</span> <span class="dt">MyString</span> <span class="fu">$</span> transform str

<span class="co">-- Turning the abstract description into some concrete representation</span>

<span class="ot">transform ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
transform (<span class="dt">MkStr</span> os) <span class="fu">=</span>  concat <span class="fu">$</span> map transformObj os

transformObj (<span class="dt">Left</span> (<span class="dt">MkWord</span> ls)) <span class="fu">=</span> 
         map (\(<span class="dt">MkLetter</span> c) <span class="ot">-&gt;</span> c) ls 
transformObj (<span class="dt">Right</span> (<span class="dt">MkBlanks</span> bs)) <span class="fu">=</span> bs</code></pre></div>
</div>
<div id="quickcheck-in-c" class="slide section level1">
<h1>QuickCheck in C++</h1>
<ul>
<li><p>Wir bauen uns unsere eigene QuickCheck Bibliothek (im Stile der Haskell Bibliothek)</p></li>
<li><p>Anwendung auf Softwarelabor Aufgabe &quot;Reguläre Ausdrücke&quot; (siehe Anhang)</p></li>
</ul>
<p>Diese Aufgabe besteht aus folgenden Teilen:</p>
<ol style="list-style-type: decimal">
<li>Vereinfachung regulärer Ausdrücke</li>
</ol>
<pre><code>  regex.simp() ==&gt; simplifiedRegEx</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Transformation regulärer Ausdrücke in endliche Automaten</li>
</ol>
<pre><code>  transform(regex) ==&gt; nfa</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Ausführung des endlichen Automaten</li>
</ol>
<pre><code>     nfa.run(word) ===&gt;  accept/not accept</code></pre>
<ul>
<li><p>Testen im Stile von QuickCheck</p>
<ul>
<li>Generierung von Testfällen
<ol style="list-style-type: decimal">
<li>Reguläre Ausdrücke (<code>regex</code>)</li>
<li>Wörter/Strings (<code>word</code>)</li>
</ol></li>
<li>Testorakel (<code>match</code>)</li>
</ul></li>
</ul>
<pre><code>      match(regex, word) ==&gt; true/false

      true = word part of the language described by regex
      false = otherwise</code></pre>
<p>Der &quot;word matcher&quot; ist gegeben (im allgemeinen bestehende stabilie Release, Testmodell etc). Dazu später mehr.</p>
<ul>
<li>QuickCheck Testen von 1.-3.</li>
</ul>
<p>Formulierung geeigneter Eigenschaften (Tests) mit Hilfe des Testorakels</p>
<p>Pseudo Code Beschreibung</p>
<pre><code>test1(regex, word) =
    match(regex.simp(), word) == match(regex,word)</code></pre>
<p>Testorakel liefert gleiches Ergebnis für simplifizierten und nicht-simplifizierten Ausdruck</p>
<pre><code>test2und3(regex,word) =
   transform(regex).run(word) == match(regex,word)</code></pre>
<p>Testorakel liefert gleiches Ergebnis für Ausführung des Automaten entstanden aus der Transformation des regulären Ausdrucks</p>
<ul>
<li>Eigentliche Aufgabe:</li>
</ul>
<p>So viele Testfälle generieren wie möglich.</p>
<h2 id="quickcheck-rahmen-in-c">QuickCheck Rahmen in C++</h2>
<p>Generisches Interface mit Hilfe von Templates (Spezialisierung) und Overloading</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
T gen();</code></pre></div>
<p>Einige spezielle Instanzen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;&gt; 
<span class="dt">int</span> gen() { <span class="kw">return</span> rand(); }

<span class="kw">template</span>&lt;&gt; 
<span class="dt">bool</span> gen() { <span class="kw">return</span> ((rand() % <span class="dv">2</span> == <span class="dv">0</span>) ? <span class="kw">true</span> : <span class="kw">false</span>); }</code></pre></div>
<p>Der QuickCheck Rahmen.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">static</span> <span class="dt">int</span> QC_MAX = <span class="dv">10</span>;

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Prop {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">bool</span> prop(T) = <span class="dv">0</span>;
};

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">bool</span> quickCheck(Prop&lt;T&gt;* p) {
  vector&lt;T&gt; v = listOfLen&lt;T&gt;(QC_MAX);
  <span class="dt">bool</span> b = <span class="kw">true</span>;

  <span class="kw">for</span> (vector&lt;<span class="dt">int</span>&gt;::iterator it = v.begin(); it != v.end(); ++it) {
    b = b &amp;&amp; p-&gt;prop(*it);
  }

  <span class="kw">return</span> b;
}</code></pre></div>
<ul>
<li>Test <code>QC_MAX</code> zufällig ausgewählte Testfälle</li>
<li>Wrapper Klasse Prop kodiert eine Funktion höherer Ordnung vom Typ <code>T -&gt; Bool</code> wobei ein Wert vom <code>T</code> ein generierter Testfall ist.</li>
</ul>
<h2 id="anwendung-auf-test1-und-test2und3">Anwendung auf Test1 und Test2und3</h2>
<p>Ein Testfall</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> TestCase {
  RE* re;
  string word;
};</code></pre></div>
<p>QuickCheck Simplifizierer</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Prop1 : <span class="kw">public</span> Prop&lt;TestCase&gt; {
  <span class="kw">public</span>:
  <span class="dt">bool</span> prop(TestCase t) {
    <span class="kw">return</span> (match(t.re-&gt;simp(), t.word) == match(t.re, t.word));
  }

};

<span class="dt">bool</span> b2 = quickCheck&lt;TestCase&gt;(<span class="kw">new</span> Prop1);</code></pre></div>
<p>QuickCheck Automat</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> Prop2und3 : <span class="kw">public</span> Prop&lt;TestCase&gt; {
  <span class="kw">public</span>:
  <span class="dt">bool</span> prop(TestCase t) {
    NFA nfa = transform(t.re);
    FSA fsa(nfa);
    <span class="kw">return</span> (fsa.run(t.word) == match(t.re, t.word));
  }
};

<span class="dt">bool</span> b2und3 = quickCheck&lt;TestCase&gt;(<span class="kw">new</span> Prop2und3);</code></pre></div>
<h2 id="testfallgeneratoren---kombinatoren">Testfallgeneratoren - Kombinatoren</h2>
<p>Liste fixer Länger</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
vector&lt;T&gt; listOfLen(<span class="dt">int</span> n) {
  vector&lt;T&gt; v;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; n; i++) {
      v.push_back(gen&lt;T&gt;());
  }
  <span class="kw">return</span> v;
};</code></pre></div>
<p>Liste beliebiger Länge</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
vector&lt;T&gt; listOf() {
  <span class="kw">return</span> listOfLen&lt;T&gt;(abs(rand()) % QC_MAX);
}</code></pre></div>
<p>Zufällige Auswahl aus (nicht leerer) Liste von Elementen</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
T oneOf(vector&lt;T&gt; v) {
  <span class="dt">int</span> i = abs(rand()) % v.size();
  <span class="kw">return</span> v[i];
}</code></pre></div>
<h2 id="testfallgeneratoren---wörter">Testfallgeneratoren - Wörter</h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">char</span> lowLetter = <span class="st">&#39;a&#39;</span>;
<span class="dt">const</span> <span class="dt">char</span> highLetter = <span class="st">&#39;c&#39;</span>;
<span class="dt">const</span> <span class="dt">int</span> maxWordLen = <span class="dv">10</span>;

<span class="co">// Zeichen</span>
<span class="kw">template</span>&lt;&gt;
<span class="dt">char</span> gen() {
  <span class="dt">int</span> l = (<span class="dt">int</span>) lowLetter;
  <span class="dt">int</span> h = (<span class="dt">int</span>) highLetter;

  <span class="co">// you try to be funny</span>
  <span class="kw">if</span> (l &gt;= h) <span class="kw">return</span> lowLetter; 

  <span class="kw">return</span> (<span class="dt">char</span>) ( (abs(rand()) % (<span class="dv">1</span> + (h - l))) + l );

}

<span class="co">// Strings</span>
<span class="kw">template</span>&lt;&gt;
string gen() {
  string str;

  <span class="dt">int</span> n = abs(rand()) % maxWordLen;

  <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; maxWordLen; i++) {
    str += gen&lt;<span class="dt">char</span>&gt;();
  }

  <span class="kw">return</span> str;
}</code></pre></div>
<p>Beachte: Bug in der Schleife, sollte sein</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    str += gen&lt;<span class="dt">char</span>&gt;();
  }</code></pre></div>
<p>Wir wollen ja Wörter beliebiger Länge zwischen 0 und maxWordLen generieren und nicht von fixer Länger maxWordLen.</p>
<p>Vorteil einer Bibliothek. Fehler werden schnell(er) entdeckt. Viele Tester benutzen die Bibliothek.</p>
<p>Vergleich. Jeder Tester schreibt Generierung selber. Je nach Tagesform schleichen sich (womöglich verschiedene) Fehler ein.</p>
<h2 id="testfallgeneratoren---reguläre-ausdrücke">Testfallgeneratoren - Reguläre Ausdrücke</h2>
<p>Schade, aber folgendes geht nicht ohne weiteres.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RE* genWontWork() {
  vector&lt;RE*&gt; v;

  v.push_back(<span class="kw">new</span> Phi);
  v.push_back(<span class="kw">new</span> Eps);
  v.push_back(<span class="kw">new</span> Ch(gen&lt;<span class="dt">char</span>&gt;()));
  v.push_back(<span class="kw">new</span> Alt(gen&lt;RE*&gt;(), gen&lt;RE*&gt;()));
  v.push_back(<span class="kw">new</span> Star(gen&lt;RE*&gt;()));
  v.push_back(<span class="kw">new</span> Conc(gen&lt;RE*&gt;(), gen&lt;RE*&gt;()));
 

  <span class="kw">return</span> oneOf&lt;RE*&gt;(v); 
}</code></pre></div>
<p>Naive Lösung, funktioniert nicht auf Grund von strikter Auswerung in C++. Problem hier ist 'oneOf' welches die Argumente strikt auswertet.</p>
<p>Echte QuickCheck Bibliotheken müssen deshalb die faule (lazy) Auswertung beherschen.</p>
<p>Unsere einfache Lösung.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;&gt;
RE* gen() {

  REType ty = (REType)( abs(rand()) % <span class="dv">6</span>);

  <span class="kw">switch</span>(ty) {
  <span class="kw">case</span> PhiType: <span class="kw">return</span> (<span class="kw">new</span> Phi);
  <span class="kw">case</span> EpsType: <span class="kw">return</span> (<span class="kw">new</span> Eps);
  <span class="kw">case</span> ChType:  <span class="kw">return</span> (<span class="kw">new</span> Ch(gen&lt;<span class="dt">char</span>&gt;()));
  <span class="kw">case</span> AltType: <span class="kw">return</span> (<span class="kw">new</span> Alt(gen&lt;RE*&gt;(), gen&lt;RE*&gt;()));
  <span class="kw">case</span> ConcType: <span class="kw">return</span> (<span class="kw">new</span> Star(gen&lt;RE*&gt;()));
  <span class="kw">default</span>: <span class="kw">return</span> (<span class="kw">new</span> Conc(gen&lt;RE*&gt;(), gen&lt;RE*&gt;())); <span class="co">// StarType</span>
  }
}</code></pre></div>
</div>
<div id="aufzeichung-und-validierung-von-programmspuren-traces" class="slide section level1">
<h1>Aufzeichung und Validierung von Programmspuren (&quot;traces&quot;)</h1>
<p>Programmverhalten wird im allgemeinen als Programmspur (&quot;trace&quot;) aufgezeichnet.</p>
<p>Was und welche Programmpunkte sollen aufgezeichnet werden?</p>
<p>Applikationsspezifisch</p>
<p>Betrachte z.B.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> someFunc(Resource f) {
 lock(f); 
 ...
 <span class="kw">if</span>(error) { <span class="kw">return</span>; }
 unlock(f);
}</code></pre></div>
<p>Ein möglicher Programmablauf der durch Programmspur festgehalten werden soll</p>
<pre><code>lock(r1) unlock(r1) lock(r2) lock(r3) unlock(r3) ...</code></pre>
<h2 id="aufzeichnung-programmspur">Aufzeichnung Programmspur</h2>
<p>Instrumentierung des Programms</p>
<ul>
<li>Automatisch</li>
<li>Per Hand</li>
</ul>
<p>Standardtrick in C</p>
<p>Verwende Macros</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="ot">#define LOCK(f)   record(f,&quot;lock&quot;); lock(f)</span>
<span class="ot">#define UNLOCK(f) record(f,&quot;unlock&quot;); unlock(f)</span>

<span class="dt">void</span> someFunc(Resource f) {
 LOCK(f); 
 ...
 <span class="kw">if</span>(error) { <span class="kw">return</span>; }
 UNLOCK(f);
}</code></pre></div>
<p>In manchen Fällen wird auf Source Code Ebene in anderen Fällen auf Byte Code Ebene instrumentiert.</p>
<p>In manchen Fällen wird Programmverhalten/Programmspur von &quot;aussen&quot; beobachtet/aufgezeichnet, z.B. Aufzeichnung von CAN Bus Daten, Netzwerkverkehr, ...</p>
<p>Endliche versus unendliche Programmspuren.</p>
<ul>
<li>Endlich = Speicherung Programmspur in einer Datei</li>
<li>Unendlich = Betrache Programmspur als einen Strom von Programmreaktionen</li>
</ul>
<p>Zusammengefasst: Es gibt viele Methoden zur Aufzeichnung der Programmspur auf verschiedenen Ebenen.</p>
<h2 id="validation-programmspur">Validation Programmspur</h2>
<p>Validation = Überprüfe auf Fehlverhalten, d.h. ob inkorrekte Muster in Programmspur</p>
<p>Validation = Musterkennung</p>
<p>Falls Fehlverhalten, dann im allgemeinen &quot;Abbruch&quot;</p>
<p>Methoden zur Validation:</p>
<ul>
<li>Überprüfung durch Skript/Programm
<ul>
<li>Mächtig und flexibel, aber fehleranfällig (Implementierungsfehler), nicht durchschaubar was und ob alles geprüft wird</li>
</ul></li>
<li>Formale Spezifikation/Logik:
<ul>
<li>Zustandsmaschine</li>
<li>Regulärer Ausdruck</li>
<li>Temporale Logik</li>
<li>...</li>
</ul></li>
</ul>
</div>
<div id="zusammenfassung" class="slide section level1">
<h1>Zusammenfassung</h1>
<ul>
<li><p>Dynamische Analyse/Testen = stimuliere, messe und überprüfe</p></li>
<li>Testen = &quot;bug-finding&quot;
<ul>
<li>Unsere Implementierung anscheinend korrekt</li>
<li>Tests nicht wegwerfen, bugs können in zukünftiger Version auftauchen</li>
</ul></li>
<li>Testfälle und Testabdeckung
<ul>
<li>Genügend Testfälle? Woher?</li>
<li>Decken die Testfälle die Spezifikation genügend ab?</li>
<li>Unterschied: Codeabdeckung versus Abdeckung der Spezifikation</li>
</ul></li>
<li>Unit-Tests:
<ul>
<li>Gegeben (INPUT, EXPECTED)</li>
<li>Messe OUTPUT</li>
<li>Vergleich OUTPUT =?= EXPECTED</li>
</ul></li>
<li>QuickCheck: Property-based testing
<ul>
<li>Spezifikation von Property (&quot;Testorakel&quot;) in Haskell (high-level language). Alternativen sind Zustandsmaschinen, ...</li>
<li>Generatoren zur Generierung zufälliger Tests</li>
<li>Im Fehlerfall, Vereinfachung (&quot;shrinking&quot;) um kleine Gegenbeispiele zu finden.</li>
</ul></li>
</ul>
<h2 id="testfallgeneratoren---fazit">Testfallgeneratoren - Fazit</h2>
<p>Generierung Testfall nun ganz einfach.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;&gt;
TestCase gen() {
  TestCase t;
  t.re = gen&lt;RE*&gt;();
  t.word = gen&lt;string&gt;();
  <span class="kw">return</span> t;
}</code></pre></div>
<p>Gibt vieles mehr</p>
<ul>
<li>Strategien für gleichmäßige Abdeckung</li>
<li>Reduktion von Testfällen im Fehlerfall</li>
<li>...</li>
</ul>
<h2 id="quickcheck-fazit">QuickCheck Fazit</h2>
<ul>
<li>Spezifikation von Testeigenschaft
<ul>
<li>Unter Ausnutzung von Testorakel</li>
</ul></li>
<li><p>Generierung von Testfällen (Benutzer-gesteuert)</p></li>
<li><p>QuickCheck Bibliotheken für verschiedene Programmiersprachen verfügbar</p></li>
<li><p><a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quviq-testing.pdf">Industriell anwendbar</a></p></li>
</ul>
</div>
<div id="anhang-kompletter-source-code-quickcheck.h" class="slide section level1">
<h1>Anhang: Kompletter Source Code <code>QuickCheck.h</code></h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// QuickCheck</span>

<span class="ot">#ifndef __QC__</span>
<span class="ot">#define __QC__</span>

<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstdlib&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Legt max Groesse von zufaelligen Listen etc fest</span>
<span class="dt">static</span> <span class="dt">int</span> QC_MAX = <span class="dv">10</span>;

<span class="co">// generisches interface</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
T gen();


<span class="co">// Einige spezielle Instanzen</span>
<span class="kw">template</span>&lt;&gt; 
<span class="dt">int</span> gen() { <span class="kw">return</span> rand(); }

<span class="kw">template</span>&lt;&gt; 
<span class="dt">bool</span> gen() { <span class="kw">return</span> ((rand() % <span class="dv">2</span> == <span class="dv">0</span>) ? <span class="kw">true</span> : <span class="kw">false</span>); }

<span class="co">// Kombinatoren</span>

<span class="co">// Liste fixer Laenger</span>

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
vector&lt;T&gt; listOfLen(<span class="dt">int</span> n) {
  vector&lt;T&gt; v;
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; n; i++) {
      v.push_back(gen&lt;T&gt;());
  }
  <span class="kw">return</span> v;
};


<span class="co">// Liste beliebiger Laenge</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
vector&lt;T&gt; listOf() {
  <span class="kw">return</span> listOfLen&lt;T&gt;(abs(rand()) % QC_MAX);
}


<span class="co">// Zufaellige Auswahl aus (nicht leerer) Liste von Elementen</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt; 
T oneOf(vector&lt;T&gt; v) {
  <span class="dt">int</span> i = abs(rand()) % v.size();
  <span class="kw">return</span> v[i];
}


<span class="co">// wrapper class um Funktionen hoehrer Ordnung zu kodieren</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">class</span> Prop {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> <span class="dt">bool</span> prop(T) = <span class="dv">0</span>;

};

<span class="co">// Zufaelliges Element welches Randbedingung erfuellt</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
T suchThat(Prop&lt;T&gt;* p) {
  T x;
  <span class="kw">do</span> {
    x = gen&lt;T&gt;();
  }
  <span class="kw">while</span>(p-&gt;prop(x));

  <span class="kw">return</span> x;
}


<span class="co">// Hauptfunktion</span>
<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="dt">bool</span> quickCheck(Prop&lt;T&gt;* p) {
  vector&lt;T&gt; v = listOfLen&lt;T&gt;(QC_MAX);
  <span class="dt">bool</span> b = <span class="kw">true</span>;

  <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; v.size(); i++) {
    b = b &amp;&amp; p-&gt;prop(v[i]);
  }

  <span class="kw">return</span> b;
}




<span class="ot">#endif </span><span class="co">// __QC__</span></code></pre></div>
</div>
<div id="anhang-testorakel" class="slide section level1">
<h1>Anhang: Testorakel</h1>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RE* deriv(RE* r, <span class="dt">char</span> l);

<span class="dt">bool</span> match(RE* r, string s) {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    r = deriv(r, s[i]);
  }
  <span class="kw">return</span> r-&gt;containsEps();
}

RE* deriv(RE* r, <span class="dt">char</span> l) {

  <span class="kw">switch</span>(r-&gt;ofType()) {
  <span class="kw">case</span> PhiType: 
    <span class="kw">return</span> r;
  <span class="kw">case</span> EpsType: 
    <span class="kw">return</span> <span class="kw">new</span> Phi();
  <span class="kw">case</span> ChType: 
    <span class="kw">if</span> (((Ch*)r)-&gt;getChar() == l) {
      <span class="kw">return</span> <span class="kw">new</span> Eps();
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Phi();
    }
  <span class="kw">case</span> StarType: {
    RE* r1 = ((Star*) r)-&gt;getRE();
    <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r);
  }
  <span class="kw">case</span> AltType: {
    RE* r1 = ((Alt*) r)-&gt;getLeft();
    RE* r2 = ((Alt*) r)-&gt;getRight();
    <span class="kw">return</span> <span class="kw">new</span> Alt(deriv(r1,l), deriv(r2,l));
  }
  <span class="kw">case</span> ConcType: { 
    RE* r1 = ((Conc*)r)-&gt;getLeft();
    RE* r2 = ((Conc*)r)-&gt;getRight();
    <span class="kw">if</span>(r1-&gt;containsEps()) {
      <span class="kw">return</span> <span class="kw">new</span> Alt(<span class="kw">new</span> Conc(deriv(r1,l),r2), deriv(r2,l));
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r2);
    }
  }

  }<span class="co">// switch</span>

}</code></pre></div>
</div>
<div id="anhang-aufgabe-reguläre-ausdrücke-und-automaten-c" class="slide section level1">
<h1>Anhang: Aufgabe Reguläre Ausdrücke und Automaten (C++)</h1>
<p>Diese Aufgabe besteht aus folgenden Teilen:</p>
<ol style="list-style-type: decimal">
<li><p>Vereinfachung regulärer Ausdrücke</p></li>
<li><p>Transformation Regulärer Ausdrücke in endliche Automaten</p></li>
<li><p>Ausführung des endlichen Automaten</p></li>
</ol>
<p>Teile der Aufgabe sind schon vorgegeben. Siehe Files <code>RE.h</code> und <code>FSA.h</code>. Ihre Aufgabe ist es, die fehlenden Teile zu vervollständigen. Die Grundgerüste der einzelnen Teilaufgaben finden Sie im ilias.</p>
<h2 id="reguläre-ausdrücke">Reguläre Ausdrücke</h2>
<p>In der theoretischen Informatik haben sie schon reguläre Ausdrücke kennengelernt. Mittels regulärer Ausdrücke lassen sich reguläre Sprache beschreiben, wobei eine Sprache aus einer Menge von Wörtern besteht. Jedes Wort besteht aus einer endlichen Anzahl von Zeichen. In unserem Fall stellen wir Zeichen als <code>char</code> dar. Deshalb sind Wörter nichts anderes als Strings.</p>
<p>Wir betrachten folgende syntaktischen Konstrukte:</p>
<ul>
<li><code>eps</code> -- &quot;Epsilon&quot; der leere String</li>
<li><code>phi</code> -- &quot;Phi&quot; die leere Sprache</li>
<li><code>c</code> -- das Zeichen <code>c</code></li>
<li><code>r1 + r2</code> -- Alternative zwischen <code>r1</code> und <code>r2</code>
<ul>
<li>Auch geschrieben als <code>r1 | r2</code></li>
</ul></li>
<li><code>r1 r2</code> -- Verkettung/Konkatenation von <code>r1</code> mit <code>r2</code></li>
<li><code>r*</code> -- Kleenesche Hülle, entweder leerer String oder beliebige Verkettung von <code>r</code></li>
</ul>
<p>Die Sprache <code>L(r)</code> beschrieben durch den regulären Ausdruck <code>r</code> ist definiert wie folgt:</p>
<ul>
<li><code>L(phi) = {}</code></li>
<li><code>L(eps) = { eps }</code></li>
<li><code>L(c) = { c }</code></li>
<li><code>L(r1 + r2) = { w | w in L(r1) oder w in L(r2) }</code></li>
<li><code>L(r1 r2) = { w1 w2 | w1 in L(r1) und w2 in L(r2) }</code></li>
<li><code>L(r*) = { w | w = eps oder w=w1 ... wn jedes wi in  L(r)  }</code></li>
</ul>
<p>Im ersten Schritt bilden wir die Syntax von regulären Ausdrücken nach C++ ab. Dazu verwenden wir Vererbung.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class RE {};
class Phi : public RE {};
class Eps : public RE {};
class Ch : public RE {
 private:
  <span class="dt">char</span> c;
 public:
  Ch (<span class="dt">char</span> _c) { c = _c; }
};
class Alt : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
};
class Conc : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Conc (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
};
class Star : public RE {
 private:
  RE* r;
 public:
  Star (RE* _r) { r = _r; }
};</code></pre></div>
<p>Z.B. die abgeleitete Klasse <code>Alt</code> repräsentiert die Alternativen zwischen zwei regulären Ausdrücken. Die Alternativen werden als private Instanzvariablen <code>r1</code> und <code>r2</code> gespeichert. Beides sind Zeiger weil, wie wir noch sehen werden, wir virtuelle Methoden auf der Basisklassen und den Ableitungen definieren werden. Der <code>Alt</code> Konstruktor bekommt als Argument zwei reguläre Ausdrücke in C++ Repräsentation und initialisiert die Instanzvariablen.</p>
<h2 id="standard-methoden-auf-regulären-ausdrücken">Standard Methoden auf Regulären Ausdrücken</h2>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class RE {
 public:
  virtual REType ofType()=<span class="dv">0</span>;
  virtual string pretty()=<span class="dv">0</span>;
  virtual bool containsEps()=<span class="dv">0</span>;
};</code></pre></div>
<p><code>ofType</code> liefert einen enum Wert, der die Art des regulären Ausdrucks kennzeichnet. <code>pretty</code> ist eine &quot;pretty print&quot; Methode, die den regulären Ausdruck in einen String übersetzt. <code>containsEps</code> liefert <code>true</code> falls in der Sprache, die vom dem reguläre Ausdruck beschrieben wird, sich der leere String befindet.</p>
<p>Obige virtuelle Methoden sind schon für die abgeleiteten Klassen definiert. Zur Lösung der Aufgaben dürfen Sie weitere (virtuelle) Methoden zur Klasse <code>RE</code> hinzufügen.</p>
<p>Als Beispiel der Definition der virtuellen Methoden, betrachten wir die abgeleitete Klasse <code>Alt</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">enum</span> REType {
  PhiType, EpsType, ChType,
  AltType, ConcType, StarType };

class Alt : public RE {
 private:
  RE* r1;
  RE* r2;
 public:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  REType ofType() { <span class="kw">return</span> AltType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(<span class="st">&quot;+&quot;</span>);
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  bool containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() || r2-&gt;containsEps());
  }
};</code></pre></div>
<p>Die Syntax von regulären Ausdrücken ist fest vorgegeben. Sprich für die Klasse <code>RE</code> gibt es keine weiteren Ableitungen, ausser den oben beschriebenen. Deshalb benutzen wir einen enum, wobei die Tags des enums jede Ableitung der Klasse <code>RE</code> beschreiben. Z.B. <code>AltType</code> beschreibt <code>Alt</code>, <code>ConcType</code> beschreibt <code>Conc</code> usw. Deshalb liefert <code>ofType</code> für die Ableitung <code>Alt</code> den Wert <code>AltType</code>.</p>
<p>Im Falle von <code>pretty</code> wird ersichtlich, wieso wir virtuelle Methoden verwenden. <code>pretty</code> wird für jede Alternative aufgerufen. Zur Laufzeit wir dann basierend auf der konkreten Instanz der Alternativen, die geeignete <code>pretty</code> Definition ausgewählt.</p>
<p>Die resultierenden Strings werden dann mit &quot;+&quot; verbunden. Beachte: Mittels Klammern &quot;(&quot; und &quot;)&quot; wird eine eindeutige Darstellunge garantiert. Z.B.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">  RE* r = new Conc (new Ch(&#39;c&#39;), new Alt(new Ch(&#39;a&#39;), new Ch(&#39;b&#39;)));
  cout &lt;&lt; r-&gt;pretty() &lt;&lt; endl;</code></pre></div>
<p>liefert <code>(c(a+b))</code>. Ohne die Klammern erhalten wir <code>ca+b</code> was nicht eindeutig ist. Natürlich könnten wir eine Präferenz zwischen den Alternativ-, Verkettungs- und Staroperator definieren, um die Anzahl der Klammern zu reduzieren (freiwillige Aufgabe).</p>
<p>Im Falle einer Alternative, ist der leere String enthalten, falls eine der beiden Alternativen den leeren String enthält. Die Methode <code>containsEps</code> setzt diese Vorgabe literal um.</p>
<h2 id="teilaufgabe-1-vereinfachung-regulärer-ausdrücke">Teilaufgabe 1: Vereinfachung Regulärer Ausdrücke</h2>
<p>Betrachte folgenden regulären Ausdruck.</p>
<pre><code>   eps ((a*)* (phi + b))</code></pre>
<p>Obiger Ausdruck kann vereinfacht werden in die Form</p>
<pre><code>   (a*) b</code></pre>
<p>Beide Ausdrücke sind äquivalent. Der letztere Ausdruck ist aber in einfacher und verständlicherer Form.</p>
<p>Ziel ist einen regulärern Ausdruck soweit wie möglich zu vereinfachen. Dazu verwenden wir Vereinfachungsregeln formuliert in der Form</p>
<pre><code> linkeSeite ==&gt; rechteSeite</code></pre>
<ol style="list-style-type: decimal">
<li><p><code>eps r ==&gt; r</code></p></li>
<li><p><code>r1 r2 ==&gt; phi</code> falls <code>L(r1)={}</code> oder <code>L(r2)={}</code></p></li>
<li><p><code>r* ==&gt; eps</code> falls <code>L(r)={}</code></p></li>
<li><p><code>(r*)* ==&gt; r*</code></p></li>
<li><p><code>r + r ==&gt; r</code></p></li>
<li><p><code>r1 + r2 ==&gt; r2</code> falls <code>L(r1)={}</code></p></li>
<li><p><code>r1 + r2 ==&gt; r1</code> falls <code>L(r2)={}</code></p></li>
</ol>
<p>Für jede der obigen Regeln gilt <code>L(linkeSeite) = L(rechteSeite)</code>.</p>
<p>Angewandt auf unser Beispiel.</p>
<pre><code>      eps ((a*)* (phi + b))
==&gt;1  (a*)* (phi + b)
==&gt;4  a* (phi + b)
==&gt;6  a* b</code></pre>
<h3 id="weiteres-vorgehen">Weiteres Vorgehen</h3>
<p>Wir erweitern Klasse <code>RE</code> wie folgt.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class RE {
 public:
  ...  
  virtual bool isPhi()=<span class="dv">0</span>;
  virtual RE* simp() { <span class="kw">return</span> this; }
};</code></pre></div>
<p>Methode <code>isPhi</code> liefert <code>true</code> falls der Ausdruck die leere Sprache beschreibt und ist schon vordefiniert.</p>
<p>Methode <code>simp</code> führt die Vereinfachungsregeln aus. Per Default liefert <code>simp</code> den ürsprünglichen Ausdruck. Ihre Aufgabe ist es <code>simp</code> in den abgeleiteten Klassen geeignet zu erweitern.</p>
<p>Als Beispiel betrachte man <code>Alt</code> und die Umsetzung der Regeln 6 und 7.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  RE* simp() { 

    <span class="co">// First, simplify subparts</span>
    r1 = r1-&gt;simp();
    r2 = r2-&gt;simp();

    <span class="co">// Then, check if any of the simplification rules are applicable</span>

    <span class="co">// 6. `r1 + r2 ==&gt; r2` falls `L(r1)={}`</span>
    <span class="kw">if</span>(r1-&gt;isPhi()) <span class="kw">return</span> r2;
    <span class="co">// 7. `r1 + r2 ==&gt; r1` falls `L(r2)={}`</span>
    <span class="kw">if</span>(r2-&gt;isPhi()) <span class="kw">return</span> r1;

    <span class="kw">return</span> <span class="kw">this</span>;
  }</code></pre></div>
<p>Etwas schwierger sind Regeln 3 und 4 im Falle von <code>Star</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  RE* simp() {

    <span class="co">// Simplify subparts</span>
    r = r-&gt;simp();

    <span class="co">// Then, check if any of the simplification rules are applicable</span>

    <span class="co">// 3. `r* ==&gt; eps` falls `L(r)={}`</span>
    <span class="kw">if</span>(r-&gt;isPhi()) {
      <span class="kw">return</span> <span class="kw">new</span> Eps();      
    } 
    <span class="co">// 4. `(r*)* ==&gt; r*`</span>
    <span class="kw">if</span>(r-&gt;ofType() == StarType) {
      <span class="kw">return</span> <span class="kw">this</span>-&gt;r;
    }  

    <span class="kw">return</span> <span class="kw">this</span>;
  }</code></pre></div>
<p>Beachte: In obiger Beispielimplementierung ignorieren wir das Problem der Speicherverwaltung. Z.B. im Falle von Regel (6) <code>r1 + r2 ==&gt; r2</code> falls <code>L(r1)={}</code> sollte jemand de von <code>r1</code> belegten Speicherbereich freigeben. In dieser Aufgabe dürfen Sie das Aufräumen der von regulären Ausdrücken Speicherplätze ignorieren. Als freiwillige Zusatzaufgabe überlegen Sie sich ein geeignetes Verwaltungsschema welches garantiert, dass der belegte Speicherplatz freigeben wird. Die Herausforderung hierbei ist zu organisieren wer und wann den Speicherplatz freigeben soll.</p>
<p>Ihre eigentliche Aufgabe ist die Implementierung der noch fehlenden obigen Vereinfachungsregeln. Für Regel (5) <code>r + r ==&gt; r</code> benötigen Sie eine Methode zum Test auf Gleichheit zwischen regulären Ausdrücken.</p>
<p>Die einfachste Implementierung wendet die <code>pretty</code> Funktion an und vergleicht dann die beiden daraus resultierenden Strings.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> equals(RE* r1, RE* r2) {
  <span class="kw">return</span> r1-&gt;pretty() == r2-&gt;pretty();
}</code></pre></div>
<p>Alternativ könnten wir rekursiv über den Strukturaufbau der regulären Ausdrücke laufen und die einzelnen Komponenten vergleichen.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> equals(RE* r1, RE* r2) {
  <span class="dt">bool</span> b;

  <span class="kw">if</span>(r1-&gt;ofType() != r2-&gt;ofType())
     <span class="kw">return</span> <span class="kw">false</span>;

  <span class="kw">switch</span>(r1-&gt;ofType()) {
    <span class="kw">case</span> PhiType: b = <span class="kw">true</span>;
                  <span class="kw">break</span>;
    <span class="kw">case</span> EpsType: b = <span class="kw">true</span>;
                  <span class="kw">break</span>;
    <span class="kw">case</span> ChType: {
                  Ch* c1 = (Ch*)r1;
                  Ch* c2 = (Ch*) r2;
                  b = c1-&gt;getChar() == c2-&gt;getChar();
                  <span class="kw">break</span>;
    }
   <span class="kw">case</span> StarType: {
                   Star* r3 = (Star*) r1;
                   Star* r4 = (Star*) r2;
                   b = equals(r3-&gt;getRE(),r4-&gt;getRE());
                   <span class="kw">break</span>;
   }
  <span class="kw">case</span> AltType: {
                 Alt* r3 = (Alt*) r1;
                 Alt* r4 = (Alt*) r2;
                 b = equals(r3-&gt;getLeft(),r4-&gt;getLeft()) &amp;&amp;
             equals(r3-&gt;getRight(), r4-&gt;getRight());
                 <span class="kw">break</span>;
  }
  <span class="kw">case</span> ConcType: {
                 Conc* r3 = (Conc*) r1;
                 Conc* r4 = (Conc*) r2;
                 b = equals(r3-&gt;getLeft(),r4-&gt;getLeft()) &amp;&amp;
             equals(r3-&gt;getRight(), r4-&gt;getRight());
                 <span class="kw">break</span>;
  }
  }<span class="co">// switch</span>
  <span class="kw">return</span> b;
} <span class="co">// equals</span></code></pre></div>
<p>Zusammengefasst. Erweiteren Sie <code>RE.h</code> mit den noch fehlenden Vereinfachungsregeln. Als eine mögliche Testroutine können Sie folgendes Gerüst verwenden.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// Main fuer Teilaufgabe 1</span>
<span class="co">// Bitte weitere Testfaelle hinzufuegen.</span>


<span class="ot">#include &quot;RE.h&quot;</span>
<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">int</span> main() {

  <span class="co">// phi + c</span>
  RE* r3 = <span class="kw">new</span> Alt (<span class="kw">new</span> Phi(), <span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>));

  <span class="co">// c + phi</span>
  RE* r4 = <span class="kw">new</span> Alt (<span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>), <span class="kw">new</span> Phi());

  cout &lt;&lt; r3-&gt;pretty() &lt;&lt; endl;

  cout &lt;&lt; r3-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  <span class="co">// c**</span>
  RE* r5 = <span class="kw">new</span> Star(<span class="kw">new</span> Star (<span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>)));

  cout &lt;&lt; r5-&gt;pretty() &lt;&lt; endl;
  cout &lt;&lt; r5-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  <span class="co">// phi*</span>
  RE* r6 = <span class="kw">new</span> Star(<span class="kw">new</span> Phi());

  cout &lt;&lt; r6-&gt;pretty() &lt;&lt; endl;
  cout &lt;&lt; r6-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  <span class="co">// (phi + c) + c**</span>
  RE* r7 = <span class="kw">new</span> Alt(r3,r5);

  cout &lt;&lt; r7-&gt;pretty() &lt;&lt; endl;
  <span class="co">// exhaustively apply simplifications</span>
  cout &lt;&lt; simpFix(r7)-&gt;pretty() &lt;&lt; endl;
}</code></pre></div>
<h2 id="teilaufgabe-2-transformation-regulärer-ausdrücke-in-automaten">Teilaufgabe 2: Transformation Regulärer Ausdrücke in Automaten</h2>
<p>Die nächste Aufgabe ist die Transformation von regulären Ausdrücken in Automaten. Ihre Aufgabe ist die Implementierung eines Transformationsalgorithmus der einen regulären Ausdruck in einen Automaten umwandelt.</p>
<h3 id="endliche-automanten">Endliche Automanten</h3>
<p>Zuerst ein kurze Wiederhohlung der grundlegenden Konzepte endlicher Automaten.</p>
<p>Ziel ist die Überprüfung, ob eine Eingabewort Teil der vom Automaten akzeptierten Sprache ist. Dazu werden nacheinander die einzelnen Zeichen des Eingabewortes betrachtet. Je nach aktuellem Zustand und aktuellem Zeichen, ändert sich der Zustand des Automaten (Beachte: Wir betrachten hier auch spontante Zustandsübergange, auch epsilon Transitionen genannt). Falls sämtliche Zeichen des Eingabewortes betrachtet, sprich konsumiert wurden, und der Automat befindet sich in einem Finalzustand, dann ist das Eingabewort Teil der vom Automaten akzeptierten Sprache.</p>
<p>Formal ist ein endlicher Automat beschrieben duch</p>
<ol style="list-style-type: decimal">
<li>Einer Menge Sigma aller Zeichen die vom Automaten behandelt werden, oft wird Sigma auch als das Alphabet des Automaten bezeichnet.</li>
<li>Einer Menge Q aller Automantenzustände.</li>
<li>Einen Initialzustand, auch Startzustand genannt, oft bezeichnet als q0 oder s0.</li>
<li>Einer Menge F von Finalzuständen, auch End- oder Stopzustände, genannt. Initialzustand und Finalzustände sind natürlich Elemente der Menge Q.</li>
<li>Einer Menge T von Transitionen, auch Übergänge genannt, von einem Zustand in den anderen. Ein Übergang (Transition) kann auf folgende zwei Arten beschrieben werden.
<ol style="list-style-type: decimal">
<li>Konsumierung eines Zeichens aus Sigma.</li>
<li>Spontaner Übergang, auch &quot;epsilon&quot; Transition genannt.</li>
</ol></li>
</ol>
<p>Beispiel:</p>
<pre><code> Sigma = {a,b,c}
 Q = {1,2,3,4,5}
 Initialzustand = 1
 Finalzustände = {4,5}
 Transitionen:
    1 -----&gt; 2
    1 --a--&gt; 3
    1 --a--&gt; 5
    2 --a--&gt; 2
    2 --b--&gt; 2
    2 --a--&gt; 3
    3 --c--&gt; 4
    5 --b--&gt; 4</code></pre>
<p>Für Eingabewort &quot;ab&quot; betrachten wir die Ausführung des Automaten.</p>
<p>Wir starten im Zustand 1. Unser Automat ist nichtdeterministisch, deshalb kann der Automat zu jeden Zeitpunkt in einer Menge von &quot;aktiven&quot; Zuständen befinden.</p>
<p>Bei der Abarbeitung des Eingabewortes gibt es zwei prinzipielle Aktionen.</p>
<ul>
<li><p>Verfolge alle spontanen Übergange, d.h. wir bilden die Hülle (englisch closure) aller spontanten Übergänge.</p></li>
<li><p>Konsumiere aktuelles Zeichen des Eingabeworts</p></li>
</ul>
<pre><code>1. current = { 1 }

Als erstes betrachten wir alle spontanen (epsilon) Übergange
die von 1 ausgehen.

Daraus folgt current = {1, 2} 
wegen      1 -----&gt; 2


Aktuelles Eingabezeichen ist a, die erste Position in &quot;ab&quot;.

Daraus folgt current = {2,3,5} wegen
    1 --a--&gt; 3
    1 --a--&gt; 5
    2 --a--&gt; 3
    2 --a--&gt; 2

2. current = {2,3,5}

 Hülle der spontanen Übergänge ist hier gleich current

Aktuelles Eingabezeichen ist b, die zweite Position in &quot;ab&quot;.

Daraus folgt current = {2,4} wegen
    2 --b--&gt; 2
    5 --b--&gt; 4

Da 4 ein Finalzustand ist, gehört &quot;ab&quot; zur der vom
dem Automaten akzeptierten Sprache.</code></pre>
<h3 id="von-regulären-ausdrücken-zu-endlichen-automaten">Von regulären Ausdrücken zu endlichen Automaten</h3>
<p>Endliche Automaten haben eine sehr einfache operationelle Beschreibung als eine Sequenz von Transitionsübergängen. In vielen Situationen sind jedoch reguläre Ausdrücke der geeignetere Formalismus. Beide Formalismen sind gleichwertig, d.h. ihre Ausdrücksstärke ist gleichwertig. Sprich jeder reguläre Ausdruck kann in einen endlichen Automaten umgewandelt werden und umgekehrt. Hier betrachten wir nur die Richtung von regulären Ausdrücken nach endlichen Automaten. Im folgenden betrachten wir einen speziellen Algorithmus der einen regulären Ausdruck in einen Automaten umwandelt (transformiert).</p>
<h4 id="thompson-nfa-algorithmus">Thompson NFA Algorithmus</h4>
<p>Ein möglicher Algorithmus ist der Thompson NFA Algorithmus beschrieben hier:</p>
<p><a href="http://en.wikipedia.org/wiki/Thompson&#39;s_construction_algorithm" class="uri">http://en.wikipedia.org/wiki/Thompson's_construction_algorithm</a></p>
<p>Gegeben sein ein regulärer Ausdruck. Der Algorithmus von Ken Thompson zeigt wie man aus dem regulärern Ausdruck einen Automaten konstruiert. Der Automat ist nichtdeterministischen weil mehrere Folgezustände nichtdeterministisch erreicht werden können. Deshalb NFA, was auf Englisch heisst &quot;non-deterministic finite automata&quot;.</p>
<p>Sie können natürlich sonst einen Algorithmus verwenden. Wichtig ist, dass der konstruierte Automat die gleiche Sprache akzeptiert, wie der reguläre Ausdruck. Zum Testen, ob Ihre Transformation diese Kriterium erfüllt wird Ihnen eine Testrahmen zur Verfügung gestellt (siehe unten).</p>
<h4 id="c-umsetzung">C++ Umsetzung</h4>
<p>Folgende Klassen sind gegeben. Bauen Sie Ihre Lösung auf Grundlage dieser Klassen auf.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class Transition;
class NFA;
class FSA;</code></pre></div>
<p><code>Transition</code> beschreibt eine Transition innerhalb eines Automaten. <code>NFA</code> beschreibt eine nicht-deterministischen Automaten, der aus einer Menge von Transitionen, einem Startzustand und einer Menge von Finalzuständen besteht. <code>FSA</code> ermöglicht die Ausführung eines NFA und wird erst später relevant.</p>
<p>Zuerst betrachen wir die Klasse <code>Transition</code>.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class Transition {
 private:
  <span class="dt">int</span> from; 
  <span class="dt">char</span> c; 
  <span class="dt">int</span> to;
  bool epsilon;
 public:

  Transition(<span class="dt">int</span> _from, <span class="dt">int</span> _to) {
    from = _from; to = _to; 
    epsilon = true;
  } 
  Transition(<span class="dt">int</span> _from, <span class="dt">char</span> _c, <span class="dt">int</span> _to) {
    from = _from; c = _c; to = _to; 
    epsilon = false;
  } 
  bool isEpsilonTransition() { <span class="kw">return</span> epsilon; }
  <span class="dt">int</span> toState() { <span class="kw">return</span> to; }
  bool trigger(<span class="dt">int</span> from, <span class="dt">char</span> c) {
    <span class="kw">return</span> (!epsilon &amp;&amp; from == this-&gt;from &amp;&amp; c == this-&gt;c);
  }
  bool trigger(<span class="dt">int</span> from) {
    <span class="kw">return</span> (epsilon &amp;&amp; from == this-&gt;from);
  }
};</code></pre></div>
<p>Zustände werden als Integer Werte repräsentiert. Eine Transition kann zwei Formen haben.</p>
<pre><code> from --- c ---&gt; to

 from ---------&gt; to</code></pre>
<p>Der Übergang von <code>from</code> nach <code>to</code> findet statt, falls die aktuelle Eingabe mit dem Zeichen <code>c</code> übereinstimmt, oder wir können spontan von <code>from</code> nach <code>to</code> übergehen. Letzer Fall ist eine sogeannte &quot;epsilon&quot; Transition. Die überladenen Konstruktoren von <code>Transition</code> erlauben die Konstruktion von Transitionen beider Arten.</p>
<p>Sind epsilon Transitionen notwendig? Nein. Jeder Automat mit epsilon Transitionen kann in einen Automaten ohne epsilon Transitionen. Jedoch sind epsilon Transitionen sehr hilfreich um nicht-deterministische Vorgänge einfach zu beschreiben. Siehe Aufgabe Übersetzung von regulären Ausdrücken nach Automaten.</p>
<p>Methode <code>isEpsilonTransition</code> unterscheidet zwischen beiden Arten. Überladene Methode <code>trigger</code> testet ob ein Übergang möglich ist. Methode <code>toState</code> liefert den Folgezustand.</p>
<p>Nun zu der <code>NFA</code> Klasse.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class NFA {
 private:
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> init;
  vector&lt;<span class="dt">int</span>&gt; final;

 public:
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, vector&lt;<span class="dt">int</span>&gt; _final) {
    ts = _ts;
    init = _init;
    final = _final;
  }
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, <span class="dt">int</span> _final) {
    ts = _ts;
    init = _init;
    final.push_back(_final);
  }
  vector&lt;Transition&gt; getTransitions() { <span class="kw">return</span> ts; }
  <span class="dt">int</span> getInitial() { <span class="kw">return</span> init; }
  vector&lt;<span class="dt">int</span>&gt; getFinals() { <span class="kw">return</span> final; }

  friend class FSA;
};</code></pre></div>
<p>Ein <code>NFA</code> besteht aus einer Menge von Transitionen, einem Startzustand und einer Menge von Finalzuständen. Wir benutzen STL <code>vector</code> zur Speicherung von Transitionen und Finalzuständen. Der zweite Konstruktor erleichert die Erstellung eines NFAs mit genau einem Start und Endzustand.</p>
<p>Ihre Aufgabe ist die Implementierung einer Transformationsfunktion von regulären Automaten (RE) nach nicht-deterministischen Automaten (NFA).</p>
<p>Es gibt mindestens zwei mögliche Ansätze.</p>
<ul>
<li>Virtuelle Methode der Klasse <code>RE</code>
<ul>
<li><code>RE.h</code> muss dann <code>FSA.h</code> importieren</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> RE {
 <span class="kw">public</span>:
   <span class="kw">virtual</span> NFA transform()=<span class="dv">0</span>;
   <span class="co">// und restliche Methoden</span>
};</code></pre></div>
<ul>
<li>Eigenständige Funktion</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">NFA transform(RE* r);</code></pre></div>
<p>Weitere Beispiele für beide Ansätze finden Sie unter Laboraufgaben (siehe Evaluator für arithmetische Ausdrücke).</p>
<p>Unten finden Sie ein Gerüst fuer den Ansatz &quot;Eigenständige Funktion&quot;. Die beiden Fälle <code>Phi</code> und <code>Alt</code> sind schon implementiert.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;FSA.h&quot;</span>
<span class="ot">#include &quot;RE.h&quot;</span>


<span class="dt">int</span> nameSupply;

<span class="dt">void</span> init() {
  nameSupply = <span class="dv">0</span>;
}

<span class="dt">int</span> fresh() {
  <span class="kw">return</span> nameSupply++;
}


<span class="co">// Macht die eigentliche Arbeit</span>
NFA transformWorker(RE *r);

<span class="co">// Schnittstelle fuer Benutzer</span>
<span class="co">// Ruecksetzen des &quot;name supplies&quot; zur Generierung von eindeutigen Zustaenden</span>
<span class="co">// Aufruf von transform2</span>
NFA transform(RE *r) {
  init();
  <span class="kw">return</span> transformWorker(r);
}


<span class="co">// Wir liefern einen NFA zurueck mit genau einem Start und</span>
<span class="co">// genau einem Stop(end)zustand.</span>
NFA transformWorker(RE *r) {
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> start, stop;

  <span class="kw">switch</span>(r-&gt;ofType()) {

  <span class="kw">case</span> EpsType: <span class="co">// TODO</span>
  <span class="kw">case</span> ChType: <span class="co">// TODO</span>
  <span class="kw">case</span> StarType: <span class="co">// TODO</span>
  <span class="kw">case</span> ConcType: <span class="co">// TODO</span>

  <span class="co">// Phi: Akzeptiert kein Wort</span>
  <span class="co">// NFA besteht aus einem Start und Stopzustand und *keiner* Transition</span>
  <span class="kw">case</span> PhiType: 
    start = fresh();
    stop = fresh();
    <span class="kw">return</span> NFA(ts, start, stop);

  <span class="kw">case</span> AltType: {
     Alt* r2 = (Alt*) r;

     <span class="co">// 1. Baue NFAs der linken und rechten Alternative</span>
     NFA n1 = transformWorker(r2-&gt;getLeft());
     NFA n2 = transformWorker(r2-&gt;getRight());

     <span class="co">// 2. Generieren neuen Start-/Stopzustand.</span>
     <span class="co">//    Sammle Start-/Stopzustaende von n1 und n2</span>
     <span class="co">// N.B. Annahme: finals besteht aus genau einem Zustand</span>
     start = fresh();
     stop = fresh();
     <span class="dt">int</span> n1_start = n1.getInitial();
     <span class="dt">int</span> n1_stop  = n1.getFinals()[<span class="dv">0</span>];
     <span class="dt">int</span> n2_start = n2.getInitial();
     <span class="dt">int</span> n2_stop  = n2.getFinals()[<span class="dv">0</span>];


     <span class="co">// 3. Sammle Transitionen auf von n1 und n2.</span>
     <span class="co">//    Verbinde neuen Start-/Endzustand mit alten Start-/Endzustaenden.</span>
     vector&lt;Transition&gt; t1 = n1.getTransitions();
     vector&lt;Transition&gt; t2 = n2.getTransitions();

     ts.insert(ts.end(),t1.begin(),t1.end());
     ts.insert(ts.end(),t2.begin(),t2.end());
     ts.push_back(Transition(start, n1_start));
     ts.push_back(Transition(start, n2_start));
     ts.push_back(Transition(n1_stop, stop));
     ts.push_back(Transition(n2_stop, stop));

     <span class="kw">return</span> NFA(ts,start,stop);
  }
      


  } <span class="co">// switch</span>

} <span class="co">// transformWorker</span></code></pre></div>
<h2 id="teilaufgabe-3-ausführung-nfa">Teilaufgabe 3: Ausführung NFA</h2>
<p>Eine weitere Aufgabe ist die Ausführung des aus dem regulären Ausdrucks konstrukierten NFA. Der Rahmen zur Ausführung wird durch die Klasse <code>FSA</code> definiert.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">class FSA : public NFA {
 private:
  vector&lt;<span class="dt">int</span>&gt; current;
  <span class="dt">void</span> closure();
 public:
  FSA(NFA fsa) : NFA(fsa.ts,fsa.init,fsa.final) {
    current.push_back(init);
    closure();
  }
  <span class="dt">void</span> reset();
  <span class="dt">void</span> step(<span class="dt">char</span> c);
  bool isFinal();
  bool run(string s);

};</code></pre></div>
<p>Ein FSA nimmt einen NFA. Instanzvariable <code>current</code> beschreibt die Menge der &quot;aktiven&quot; Zustände. Beachte wir gehen von einem nicht-deterministischen Automaten aus. Im Falle eines deterministischen Automaten, würde die Menge aus genau einem Zustand bestehen.</p>
<p>Am Anfang wird <code>current</code> gleich dem Startzustand des NFA gesetzt. Übergänge finden nur statt (sprich Transitionen werden getriggert) bei Lesen eines Zeichens. Da der NFA &quot;epsilon&quot; Transitionen enthält, müssen wir alle von <code>current</code> aus erreichbaren Zustände bilden die via einer oder mehrerer epsilon Transitionenen erreichbar sind. Dies geschieht durch Aufruf der Methode <code>closure</code>.</p>
<h3 id="closure"><code>closure</code></h3>
<p>Ihre Aufgabe ist es Methode <code>closure</code> zu implementieren. Zuerst betrachten wir ein Beispiel mit folgenden drei Transitionen (Zustandsübergängen).</p>
<pre><code>s1 -----&gt; s2
s2 --a--&gt; s3
s2 -----&gt; s4</code></pre>
<p>Von Zustand <code>s1</code> gibt es eine &quot;epsilon&quot; Transition nach <code>s2</code>. Von Zustand <code>s2</code> ist ein Übergang in den Zustand <code>s3</code> möglich, falls die aktuelle Eingabe <code>a</code> ist. Der letzte Zustandsübergang ist wieder ein &quot;epsilon&quot; Transition.</p>
<p>Annahme: <code>current = {s1}</code></p>
<ol style="list-style-type: decimal">
<li>Schritt <code>current = {s1, s2}</code> wegen folgender &quot;epsilon&quot; Transition <code>s1 -----&gt; s2</code>.</li>
</ol>
<p>Aufgrund des neu hinzugefügten Zustandes <code>s2</code> können weitere Zustände via &quot;epsilon&quot; erreicht werden.</p>
<ol start="2" style="list-style-type: decimal">
<li>Schritt: <code>current = {s1, s2, s4}</code> wegen &quot;epsilon&quot; Transition <code>s2 -----&gt; s4</code>.</li>
</ol>
<p>Keine weiteren Zustände können via &quot;epsilon&quot; erreicht werden. Die <code>closure</code> von <code>{s1}</code> ist <code>{s1,s2,s4}</code>.</p>
<p>Beachte, Zustand <code>s3</code> kann nur erreicht werden falls die aktuelle Eingabe <code>a</code> ist. Deshalb ist <code>s3</code> nicht in der <code>closure</code> von <code>{s1}</code>.</p>
<p>Hinweise zur Implementierung von <code>closure</code>:</p>
<p>Für jeden Zustand <code>s1</code> in <code>current</code> und jede &quot;epsilon&quot; Transition <code>s2 -----&gt; s3</code>, fügen wir <code>s3</code> zu <code>current</code> hinzu falls folgende Bedingungen gelten:</p>
<ul>
<li>`s1 == s2'</li>
<li><code>s3</code> ist nicht schon enthalten in <code>current</code></li>
</ul>
<p>Dieser Vorgang wird solange ausgeführt, bis keine Zustände mehr zu <code>current</code> hinzugefügt werden können.</p>
<p>Im Detail:</p>
<ol style="list-style-type: decimal">
<li>Iterieren Sie über die Menge der Transitionen.</li>
<li>Mit Hilfe der Methode <code>isEpsilonTransition</code> der Klasse <code>Transition</code> können Sie alle epsilon Transitionen herausfiltern.</li>
<li>Mit Hilfe der Methoden <code>trigger</code> und <code>toState</code> der Klasse <code>Transition</code> können Sie Testen, ob ein Zustand erreicht wird. Angenommen <code>t</code> ist eine Transition und <code>q</code> ein Zustand (Integer), dann liefert der Ausdruck <code>t.isEpsilonTransition() &amp;&amp; t.trigger(q)</code> wahr, falls <code>t</code> eine epsilon Transition ist und Transition <code>t als Startpunkt den Zustand</code>q<code>hat.    Via</code>t.toState(q)` können Sie den Endpunkt der (epsilon) Transition berechnen.</li>
<li>Um zu überprüfen, ob ein Element in einem Vektor ist benutzen Sie die <code>find</code> Method. Angenommen <code>v</code> ist vom Typ <code>vector&lt;int&gt;</code> und <code>q</code> ist ein Zustand, dann liefert der Ausdruck <code>find(v.begin(),v.end(),q) == v.end()</code> wahr, falls <code>q</code> nicht in dem Vektor <code>v</code> enthalten ist.</li>
</ol>
<h3 id="weitere-methoden">Weitere Methoden</h3>
<p>Methoden <code>reset</code>, <code>isFinal</code>, <code>step</code> und <code>run</code> sind schon gegeben.</p>
<p>Ein <code>reset</code> bedeutet, wir brechen die Ausführung ab, und starten neu:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> FSA::reset() {
    current.clear();
    current.push_back(init);
    closure();
}</code></pre></div>
<p>Methoden <code>isFinal</code> überprüft, ob wir einen Finalzustand erreicht haben:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> FSA::isFinal() {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; <span class="kw">final</span>.size(); i++) {
      <span class="kw">if</span>(find(current.begin(),current.end(),<span class="kw">final</span>[i]) != current.end())
    <span class="kw">return</span> <span class="kw">true</span>;
    }     
    <span class="kw">return</span> <span class="kw">false</span>;
}</code></pre></div>
<p>Methode <code>step</code> nimmt als Eingabe das aktuelle Zeichen <code>c</code>. Basierend auf der Menge der &quot;aktiven&quot; Zustände in <code>current</code>, werden alle Folgezustände berechnet die mit der Eingabe <code>c</code> erreicht werden können. Diese Menge wird gleich <code>current</code> gesetzt. Es folgt das bilden der transitiven Hülle der &quot;epsilon&quot; Transitionen mittels <code>closure</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> FSA::step(<span class="dt">char</span> c) {
    vector&lt;<span class="dt">int</span>&gt; next;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; ts.size(); i++) {
      <span class="kw">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j &lt; current.size(); j++) {
        <span class="kw">if</span>(ts[i].trigger(current[j],c))
      next.push_back(ts[i].toState());
      }
    }
    current = next;
    closure();
}</code></pre></div>
<p>Methode <code>run</code> überprüft ob der Eingabestring von dem Automaten akzeptiert wird.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> FSA::run(string s) {
  reset();
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    step(s[i]);
  }
  <span class="kw">return</span> isFinal();
}</code></pre></div>
<h2 id="testrahmen">Testrahmen</h2>
<p>Zum Testen der Teilaufgaben benutzen Sie bitte folgenden Testrahmen.</p>
<p>Annahme: Sie haben <code>FSA.h</code> mit einer Implementierung der <code>closure</code> Funktion erweitert und Teilaufgbe 1 as eingenständige Funktion folgender Form realisiert (falls als Methode, müssen Sie einfach den transform Aufruf geeignet umschreiben).</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">NFA transform(RE *r);</code></pre></div>
<h3 id="testorakel">Testorakel</h3>
<p>Zur Überprüfung, ob ihre Implemenierung korrekt ist benötigen wir eine unabhängige Implementierung eines Automaten.</p>
<p>Die untenstehende Implementierung beruht auf Brzozowski's Derivaten. Die Details sind unwichtig. Falls Sie's interessiert, weitere Informationen finden Sie <a href="hier">http://lambda-the-ultimate.org/node/2293</a>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">RE* deriv(RE* r, <span class="dt">char</span> l) {

  <span class="kw">switch</span>(r-&gt;ofType()) {
  <span class="kw">case</span> PhiType: 
    <span class="kw">return</span> r;
  <span class="kw">case</span> EpsType: 
    <span class="kw">return</span> <span class="kw">new</span> Phi();
  <span class="kw">case</span> ChType: 
    <span class="kw">if</span> (((Ch*)r)-&gt;getChar() == l) {
      <span class="kw">return</span> <span class="kw">new</span> Eps();
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Phi();
    }
  <span class="kw">case</span> StarType: {
    RE* r1 = ((Star*) r)-&gt;getRE();
    <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r);
  }
  <span class="kw">case</span> AltType: {
    RE* r1 = ((Alt*) r)-&gt;getLeft();
    RE* r2 = ((Alt*) r)-&gt;getRight();
    <span class="kw">return</span> <span class="kw">new</span> Alt(deriv(r1,l), deriv(r2,l));
  }
  <span class="kw">case</span> ConcType: { 
    RE* r1 = ((Conc*)r)-&gt;getLeft();
    RE* r2 = ((Conc*)r)-&gt;getRight();
    <span class="kw">if</span>(r1-&gt;containsEps()) {
      <span class="kw">return</span> <span class="kw">new</span> Alt(<span class="kw">new</span> Conc(deriv(r1,l),r2), deriv(r2,l));
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r2);
    }
  }

  }<span class="co">// switch</span>

}

<span class="dt">bool</span> match(RE* r, string s) {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    r = deriv(r, s[i]);
  }
  <span class="kw">return</span> r-&gt;containsEps();
}</code></pre></div>
<h3 id="testausführung">Testausführung</h3>
<p>Ein Testfall besteht aus einem regulären Ausdruck und einem Eingabestring. Testausführung ist wie folgt.</p>
<ol style="list-style-type: decimal">
<li>Transformiere RE nach NFA</li>
<li>Baue FSA</li>
<li>Fuehre FSA fuer Eingabestring aus (&quot;run&quot;)</li>
<li>Ueberpruefe ob Eingabestring in RE enthalten</li>
<li>Rueckgabe true falls Ergebnisse 3. und 4. uebereinstimmen. Sprich das Testorakel (Referenzimplementierung) und Ihre Implementierung liefern das gleiche Ergebnis. Ansonsten Rueckgabe false.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> testExec(RE* r, string s) {
  NFA nfa = transform(r);
  FSA fsa(nfa);
  <span class="dt">bool</span> b1 = fsa.run(s);
  <span class="dt">bool</span> b2 = match(r,s);

  <span class="kw">return</span> b1 == b2;
}</code></pre></div>
<h3 id="main">main</h3>
<p>Unten finden Sie ein paar einfache Testfälle. Sie sollten natürlich Ihre Implementierung gegen weitere Fälle testen.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main() {

  <span class="co">// Testfaelle</span>

  <span class="co">// (ab)*</span>
  RE * r1 = <span class="kw">new</span> Star(<span class="kw">new</span> Conc(<span class="kw">new</span> Ch(<span class="st">&#39;a&#39;</span>), <span class="kw">new</span> Ch(<span class="st">&#39;b&#39;</span>)));
  string s1 = <span class="st">&quot;abab&quot;</span>;

  cout &lt;&lt; testExec(r1,s1) &lt;&lt; endl;

  string s2 = <span class="st">&quot;ababa&quot;</span>;

  cout &lt;&lt; testExec(r1,s2) &lt;&lt; endl;
}</code></pre></div>
</div>
<div id="anhang-zu-aufgabe-4" class="slide section level1">
<h1>Anhang zu Aufgabe 4</h1>
<p>Auch verfügbar via ilias.</p>
<h2 id="fsa.h"><code>FSA.h</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// File: FSA.h</span>
<span class="co">// Endliche Automaten</span>

<span class="ot">#ifndef __FSA__</span>
<span class="ot">#define __FSA__</span>

<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;algorithm&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">class</span> Transition;
<span class="kw">class</span> NFA;
<span class="kw">class</span> FSA;



<span class="kw">class</span> Transition {
 <span class="kw">private</span>:
  <span class="dt">int</span> from; 
  <span class="dt">char</span> c; 
  <span class="dt">int</span> to;
  <span class="dt">bool</span> epsilon;
 <span class="kw">public</span>:

  Transition(<span class="dt">int</span> _from, <span class="dt">int</span> _to) {
    from = _from; to = _to; 
    epsilon = <span class="kw">true</span>;
  } 
  Transition(<span class="dt">int</span> _from, <span class="dt">char</span> _c, <span class="dt">int</span> _to) {
    from = _from; c = _c; to = _to; 
    epsilon = <span class="kw">false</span>;
  } 
  <span class="dt">bool</span> isEpsilonTransition() { <span class="kw">return</span> epsilon; }
  <span class="dt">int</span> toState() { <span class="kw">return</span> to; }
  <span class="dt">bool</span> trigger(<span class="dt">int</span> from, <span class="dt">char</span> c) {
    <span class="kw">return</span> (!epsilon &amp;&amp; from == <span class="kw">this</span>-&gt;from &amp;&amp; c == <span class="kw">this</span>-&gt;c);
  }
  <span class="dt">bool</span> trigger(<span class="dt">int</span> from) {
    <span class="kw">return</span> (epsilon &amp;&amp; from == <span class="kw">this</span>-&gt;from);
  }
};

<span class="kw">class</span> NFA {
 <span class="kw">private</span>:
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> init;
  vector&lt;<span class="dt">int</span>&gt; <span class="kw">final</span>;

 <span class="kw">public</span>:
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, vector&lt;<span class="dt">int</span>&gt; _final) {
    ts = _ts;
    init = _init;
    <span class="kw">final</span> = _final;
  }
  NFA(vector&lt;Transition&gt; _ts, <span class="dt">int</span> _init, <span class="dt">int</span> _final) {
    ts = _ts;
    init = _init;
    <span class="kw">final</span>.push_back(_final);
  }
  vector&lt;Transition&gt; getTransitions() { <span class="kw">return</span> ts; }
  <span class="dt">int</span> getInitial() { <span class="kw">return</span> init; }
  vector&lt;<span class="dt">int</span>&gt; getFinals() { <span class="kw">return</span> <span class="kw">final</span>; }

  <span class="kw">friend</span> <span class="kw">class</span> FSA;
};

<span class="kw">class</span> FSA : <span class="kw">public</span> NFA {
 <span class="kw">private</span>:
  vector&lt;<span class="dt">int</span>&gt; current;
  <span class="dt">void</span> closure();
 <span class="kw">public</span>:
  FSA(NFA fsa) : NFA(fsa.ts,fsa.init,fsa.<span class="kw">final</span>) {
    current.push_back(init);
    closure();
  }
  <span class="dt">void</span> reset();
  <span class="dt">void</span> step(<span class="dt">char</span> c);
  <span class="dt">bool</span> isFinal();
  <span class="dt">bool</span> run(string s);

};

<span class="dt">void</span> FSA::reset() {
    current.clear();
    current.push_back(init);
    closure();
}

<span class="dt">bool</span> FSA::isFinal() {
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; <span class="kw">final</span>.size(); i++) {
      <span class="kw">if</span>(find(current.begin(),current.end(),<span class="kw">final</span>[i]) != current.end())
    <span class="kw">return</span> <span class="kw">true</span>;
    }     
    <span class="kw">return</span> <span class="kw">false</span>;
}

<span class="dt">void</span> FSA::closure() {
 <span class="co">// Ihre Aufgabe</span>
}

<span class="dt">void</span> FSA::step(<span class="dt">char</span> c) {
    vector&lt;<span class="dt">int</span>&gt; next;
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; ts.size(); i++) {
      <span class="kw">for</span> (<span class="dt">int</span> j=<span class="dv">0</span>; j &lt; current.size(); j++) {
        <span class="kw">if</span>(ts[i].trigger(current[j],c))
      next.push_back(ts[i].toState());
      }
    }
    current = next;
    closure();
}

<span class="dt">bool</span> FSA::run(string s) {
  reset();
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    step(s[i]);
  }
  <span class="kw">return</span> isFinal();
}


<span class="ot">#endif </span><span class="co">// __FSA__</span></code></pre></div>
<h2 id="re.h"><code>RE.h</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Reguläre Ausdrücke</span>

<span class="ot">#ifndef __RE__</span>
<span class="ot">#define __RE__</span>

<span class="ot">#include &lt;string&gt;</span>
<span class="ot">#include &lt;sstream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// Vorwaertzreferenz</span>
<span class="kw">class</span> RE;

<span class="co">// Prototypen von Hilfsfunktionen</span>
<span class="dt">bool</span> equals(RE* r1, RE* r2);

<span class="kw">enum</span> REType {
  PhiType,
  EpsType,
  ChType,
  AltType,
  ConcType,
  StarType };


<span class="co">// Basisklasse</span>
<span class="kw">class</span> RE {
 <span class="kw">public</span>:
  <span class="kw">virtual</span> REType ofType()=<span class="dv">0</span>;
  <span class="kw">virtual</span> string pretty()=<span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">bool</span> containsEps()=<span class="dv">0</span>;
  <span class="kw">virtual</span> <span class="dt">bool</span> isPhi()=<span class="dv">0</span>;
  <span class="kw">virtual</span> RE* simp() { <span class="kw">return</span> <span class="kw">this</span>; }
};

<span class="co">// Abgeleitete Klassen</span>

<span class="kw">class</span> Phi : <span class="kw">public</span> RE {
 <span class="kw">public</span>:
  REType ofType() { <span class="kw">return</span> PhiType; }
  string pretty() { <span class="kw">return</span> <span class="st">&quot;phi&quot;</span>; }
  <span class="dt">bool</span> containsEps() { <span class="kw">return</span> <span class="kw">false</span>; }
  <span class="dt">bool</span> isPhi() { <span class="kw">return</span> <span class="kw">true</span>; }
};

<span class="kw">class</span> Eps : <span class="kw">public</span> RE {
 <span class="kw">public</span>:
  REType ofType() { <span class="kw">return</span> EpsType; }
  string pretty() { <span class="kw">return</span> <span class="st">&quot;eps&quot;</span>; }
  <span class="dt">bool</span> containsEps() { <span class="kw">return</span> <span class="kw">true</span>; }
  <span class="dt">bool</span> isPhi() { <span class="kw">return</span> <span class="kw">false</span>; }
};

<span class="kw">class</span> Ch : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  <span class="dt">char</span> c;
 <span class="kw">public</span>:
  Ch (<span class="dt">char</span> _c) { c = _c; }
  <span class="dt">char</span> getChar() { <span class="kw">return</span> c; }
  REType ofType() { <span class="kw">return</span> ChType; }
  string pretty() {
    stringstream ss;
    ss &lt;&lt; c;
    <span class="kw">return</span> ss.str();
  }
  <span class="dt">bool</span> containsEps() { <span class="kw">return</span> <span class="kw">false</span>; }
  <span class="dt">bool</span> isPhi() { <span class="kw">return</span> <span class="kw">false</span>; }
};

<span class="kw">class</span> Alt : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  RE* r1;
  RE* r2;
 <span class="kw">public</span>:
  Alt (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  RE* getLeft() { <span class="kw">return</span> r1; }
  RE* getRight() { <span class="kw">return</span> r2; }
  REType ofType() { <span class="kw">return</span> AltType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(<span class="st">&quot;+&quot;</span>);
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  <span class="dt">bool</span> containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() || r2-&gt;containsEps());
  }
  <span class="dt">bool</span> isPhi() { 
    <span class="kw">return</span> (r1-&gt;isPhi() &amp;&amp; r2-&gt;isPhi());
  }
  RE* simp() { 

    <span class="co">// First, simplify subparts</span>
    r1 = r1-&gt;simp();
    r2 = r2-&gt;simp();

    <span class="co">// Then, check if any of the simplification rules are applicable</span>

    <span class="co">// 6. `r1 + r2 ==&gt; r2` falls `L(r1)={}`</span>
    <span class="kw">if</span>(r1-&gt;isPhi()) <span class="kw">return</span> r2;
    <span class="co">// 7. `r1 + r2 ==&gt; r1` falls `L(r2)={}`</span>
    <span class="kw">if</span>(r2-&gt;isPhi()) <span class="kw">return</span> r1;

    <span class="kw">return</span> <span class="kw">this</span>;
  
    <span class="co">// N.B. We&#39;re a bit relaxed when it comes to garbage collection.</span>
    <span class="co">// For example, in case of rule (6) we should clean up the</span>
    <span class="co">// memory space occupied by r1 which we ignore here.</span>
  }
};

<span class="kw">class</span> Conc : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  RE* r1;
  RE* r2;
 <span class="kw">public</span>:
  Conc (RE* _r1, RE* _r2) { r1 = _r1; r2 = _r2; }
  RE* getLeft() { <span class="kw">return</span> r1; }
  RE* getRight() { <span class="kw">return</span> r2; }
  REType ofType() { <span class="kw">return</span> ConcType; }
  string pretty() {
    string s(<span class="st">&quot;(&quot;</span>);
    s.append(r1-&gt;pretty());
    s.append(r2-&gt;pretty());
    s.append(<span class="st">&quot;)&quot;</span>);
    <span class="kw">return</span> s;
  }
  <span class="dt">bool</span> containsEps() { 
    <span class="kw">return</span> (r1-&gt;containsEps() &amp;&amp; r2-&gt;containsEps());
  }
  <span class="dt">bool</span> isPhi() { 
    <span class="kw">return</span> (r1-&gt;isPhi() || r2-&gt;isPhi());
  }
};

<span class="kw">class</span> Star : <span class="kw">public</span> RE {
 <span class="kw">private</span>:
  RE* r;
 <span class="kw">public</span>:
  Star (RE* _r) { r = _r; }
  RE* getRE() { <span class="kw">return</span> r; }
  REType ofType() { <span class="kw">return</span> StarType; }
  string pretty() {
    string s;
    s.append(r-&gt;pretty());
    s.append(<span class="st">&quot;*&quot;</span>);
    <span class="kw">return</span> s;
  }
  <span class="dt">bool</span> containsEps() { 
    <span class="kw">return</span> <span class="kw">true</span>;
  }
  <span class="dt">bool</span> isPhi() { 
    <span class="kw">return</span> <span class="kw">false</span>;
  }
  RE* simp() {

    <span class="co">// Simplify subparts</span>
    r = r-&gt;simp();

    <span class="co">// Then, check if any of the simplification rules are applicable</span>

    <span class="co">// 3. `r* ==&gt; eps` falls `L(r)={}`</span>
    <span class="kw">if</span>(r-&gt;isPhi()) {
      <span class="kw">return</span> <span class="kw">new</span> Eps();      
    } 
    <span class="co">// 4. `(r*)* ==&gt; r*`</span>
    <span class="kw">if</span>(r-&gt;ofType() == StarType) {
      <span class="kw">return</span> <span class="kw">this</span>-&gt;r;
    }  

    <span class="kw">return</span> <span class="kw">this</span>;
  }
};


<span class="co">// Structural comparison among regular expressions</span>
<span class="dt">bool</span> equals(RE* r1, RE* r2) {
  <span class="dt">bool</span> b;

  <span class="kw">if</span>(r1-&gt;ofType() != r2-&gt;ofType())
     <span class="kw">return</span> <span class="kw">false</span>;

  <span class="kw">switch</span>(r1-&gt;ofType()) {
    <span class="kw">case</span> PhiType: b = <span class="kw">true</span>;
                  <span class="kw">break</span>;
    <span class="kw">case</span> EpsType: b = <span class="kw">true</span>;
                  <span class="kw">break</span>;
    <span class="kw">case</span> ChType: {
                  Ch* c1 = (Ch*)r1;
                  Ch* c2 = (Ch*) r2;
                  b = c1-&gt;getChar() == c2-&gt;getChar();
                  <span class="kw">break</span>;
    }
   <span class="kw">case</span> StarType: {
                   Star* r3 = (Star*) r1;
                   Star* r4 = (Star*) r2;
                   b = equals(r3-&gt;getRE(),r4-&gt;getRE());
                   <span class="kw">break</span>;
   }
  <span class="kw">case</span> AltType: {
                 Alt* r3 = (Alt*) r1;
                 Alt* r4 = (Alt*) r2;
                 b = equals(r3-&gt;getLeft(),r4-&gt;getLeft()) &amp;&amp;
             equals(r3-&gt;getRight(), r4-&gt;getRight());
                 <span class="kw">break</span>;
  }
  <span class="kw">case</span> ConcType: {
                 Conc* r3 = (Conc*) r1;
                 Conc* r4 = (Conc*) r2;
                 b = equals(r3-&gt;getLeft(),r4-&gt;getLeft()) &amp;&amp;
             equals(r3-&gt;getRight(), r4-&gt;getRight());
                 <span class="kw">break</span>;
  }
  }<span class="co">// switch</span>
  <span class="kw">return</span> b;
} <span class="co">// equals</span>



<span class="co">// Repeated application of simp until we reach a fixpoint</span>
RE* simpFix(RE* r1) {
  RE* r2 = r1-&gt;simp();
  
  <span class="kw">if</span>(equals(r1,r2)) 
       <span class="kw">return</span> r1;

  <span class="kw">return</span> simpFix(r2);
}

<span class="ot">#endif </span><span class="co">// __RE__</span></code></pre></div>
<h2 id="transform.h"><code>Transform.h</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Ein moeglicher Rahmen fuer Aufgabe 4, zweite Teilaufgabe,</span>
<span class="co">// uebersetze regulaeren Ausdruck in einen NFA.</span>
<span class="co">// Der Einfachheit in ein .h File gepackt.</span>


<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;FSA.h&quot;</span>
<span class="ot">#include &quot;RE.h&quot;</span>


<span class="dt">int</span> nameSupply;

<span class="dt">void</span> init() {
  nameSupply = <span class="dv">0</span>;
}

<span class="dt">int</span> fresh() {
  <span class="kw">return</span> nameSupply++;
}


<span class="co">// Macht die eigentliche Arbeit</span>
NFA transformWorker(RE *r);

<span class="co">// Schnittstelle fuer Benutzer</span>
<span class="co">// Ruecksetzen des &quot;name supplies&quot; zur Generierung von eindeutigen Zustaenden</span>
<span class="co">// Aufruf von transform2</span>
NFA transform(RE *r) {
  init();
  <span class="kw">return</span> transformWorker(r);
}


<span class="co">// Wir liefern einen NFA zurueck mit genau einem Start und</span>
<span class="co">// genau einem Stop(end)zustand.</span>
NFA transformWorker(RE *r) {
  vector&lt;Transition&gt; ts;
  <span class="dt">int</span> start, stop;

  <span class="kw">switch</span>(r-&gt;ofType()) {

  <span class="kw">case</span> EpsType: <span class="co">// TODO</span>
  <span class="kw">case</span> ChType: <span class="co">// TODO</span>
  <span class="kw">case</span> StarType: <span class="co">// TODO</span>
  <span class="kw">case</span> ConcType: <span class="co">// TODO</span>

  <span class="co">// Phi: Akzeptiert kein Wort</span>
  <span class="co">// NFA besteht aus einem Start und Stopzustand und *keiner* Transition</span>
  <span class="kw">case</span> PhiType: 
    start = fresh();
    stop = fresh();
    <span class="kw">return</span> NFA(ts, start, stop);

  <span class="kw">case</span> AltType: {
     Alt* r2 = (Alt*) r;

     <span class="co">// 1. Baue NFAs der linken und rechten Alternative</span>
     NFA n1 = transformWorker(r2-&gt;getLeft());
     NFA n2 = transformWorker(r2-&gt;getRight());

     <span class="co">// 2. Generieren neuen Start-/Stopzustand.</span>
     <span class="co">//    Sammle Start-/Stopzustaende von n1 und n2</span>
     <span class="co">// N.B. Annahme: finals besteht aus genau einem Zustand</span>
     start = fresh();
     stop = fresh();
     <span class="dt">int</span> n1_start = n1.getInitial();
     <span class="dt">int</span> n1_stop  = n1.getFinals()[<span class="dv">0</span>];
     <span class="dt">int</span> n2_start = n2.getInitial();
     <span class="dt">int</span> n2_stop  = n2.getFinals()[<span class="dv">0</span>];


     <span class="co">// 3. Sammle Transitionen auf von n1 und n2.</span>
     <span class="co">//    Verbinde neuen Start-/Endzustand mit alten Start-/Endzustaenden.</span>
     vector&lt;Transition&gt; t1 = n1.getTransitions();
     vector&lt;Transition&gt; t2 = n2.getTransitions();

     ts.insert(ts.end(),t1.begin(),t1.end());
     ts.insert(ts.end(),t2.begin(),t2.end());
     ts.push_back(Transition(start, n1_start));
     ts.push_back(Transition(start, n2_start));
     ts.push_back(Transition(n1_stop, stop));
     ts.push_back(Transition(n2_stop, stop));

     <span class="kw">return</span> NFA(ts,start,stop);
  }
      


  } <span class="co">// switch</span>


} <span class="co">// transformWorker</span></code></pre></div>
<h2 id="testorakel.h"><code>TestOrakel.h</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">//////////////////////////////////</span>
<span class="co">// Testorakel</span>
<span class="co">// der Einfachheit alles in ein .h File gepackt</span>

<span class="ot">#include &quot;RE.h&quot;</span>

<span class="co">// Testorakel</span>
RE* deriv(RE* r, <span class="dt">char</span> l) {

  <span class="kw">switch</span>(r-&gt;ofType()) {
  <span class="kw">case</span> PhiType: 
    <span class="kw">return</span> r;
  <span class="kw">case</span> EpsType: 
    <span class="kw">return</span> <span class="kw">new</span> Phi();
  <span class="kw">case</span> ChType: 
    <span class="kw">if</span> (((Ch*)r)-&gt;getChar() == l) {
      <span class="kw">return</span> <span class="kw">new</span> Eps();
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Phi();
    }
  <span class="kw">case</span> StarType: {
    RE* r1 = ((Star*) r)-&gt;getRE();
    <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r);
  }
  <span class="kw">case</span> AltType: {
    RE* r1 = ((Alt*) r)-&gt;getLeft();
    RE* r2 = ((Alt*) r)-&gt;getRight();
    <span class="kw">return</span> <span class="kw">new</span> Alt(deriv(r1,l), deriv(r2,l));
  }
  <span class="kw">case</span> ConcType: { 
    RE* r1 = ((Conc*)r)-&gt;getLeft();
    RE* r2 = ((Conc*)r)-&gt;getRight();
    <span class="kw">if</span>(r1-&gt;containsEps()) {
      <span class="kw">return</span> <span class="kw">new</span> Alt(<span class="kw">new</span> Conc(deriv(r1,l),r2), deriv(r2,l));
    }
    <span class="kw">else</span> {
      <span class="kw">return</span> <span class="kw">new</span> Conc(deriv(r1,l),r2);
    }
  }

  }<span class="co">// switch</span>

}

<span class="dt">bool</span> match(RE* r, string s) {
  <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i &lt; s.length(); i++) {
    r = deriv(r, s[i]);
  }
  <span class="kw">return</span> r-&gt;containsEps();
}</code></pre></div>
<h2 id="testteil1.cpp"><code>testTeil1.cpp</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Testrahmen fuer 1. Teilaufgabe</span>

<span class="ot">#include &quot;RE.h&quot;</span>
<span class="ot">#include &quot;FSA.h&quot;</span>

<span class="ot">#include &quot;TestOrakel.h&quot;</span>

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="co">// Systematischer Test</span>

<span class="co">// Ein Testfall besteht aus einem regulaeren Ausdruck (RE)</span>
<span class="co">// und einem Eingabestring.</span>
<span class="co">// </span>
<span class="co">// Testorakel match ueberprueft ob string s enthalten in regex r.</span>
<span class="co">// </span>
<span class="co">// Simplifizierer korrekt fuer Testfall, falls Testorakel gleiches</span>
<span class="co">// Ergebnis liefert fuer Original regex r und simplifizierten regex r-&gt;simp()</span>

<span class="dt">bool</span> testSimp(RE* r, string s) {
  <span class="dt">bool</span> b = (match(r,s) == match(r-&gt;simp(),s));

  cout &lt;&lt; <span class="st">&quot;Test case: &quot;</span> &lt;&lt; r-&gt;pretty() &lt;&lt; <span class="st">&quot;   &quot;</span> &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
  cout &lt;&lt; <span class="st">&quot;Test result: &quot;</span> &lt;&lt; b &lt;&lt; endl;

  <span class="kw">return</span> b;
}

<span class="dt">int</span> main() {

  cout &lt;&lt; <span class="st">&quot;Ein paar Testfaelle. Ueberpruefung per Auge&quot;</span> &lt;&lt; endl;


  RE* r3 = <span class="kw">new</span> Alt (<span class="kw">new</span> Phi(), <span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>));

  RE* r4 = <span class="kw">new</span> Alt (<span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>), <span class="kw">new</span> Phi());

  cout &lt;&lt; r3-&gt;pretty() &lt;&lt; endl;

  cout &lt;&lt; r3-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  RE* r5 = <span class="kw">new</span> Star(<span class="kw">new</span> Star (<span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>)));

  cout &lt;&lt; r5-&gt;pretty() &lt;&lt; endl;
  cout &lt;&lt; r5-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  RE* r6 = <span class="kw">new</span> Star(<span class="kw">new</span> Phi());

  cout &lt;&lt; r6-&gt;pretty() &lt;&lt; endl;
  cout &lt;&lt; r6-&gt;simp()-&gt;pretty() &lt;&lt; endl;

  cout &lt;&lt; <span class="st">&quot;Verwende testSimp&quot;</span> &lt;&lt; endl;

  testSimp(r5, <span class="st">&quot;ab&quot;</span>);

  <span class="co">// TODO: mehr Tests</span>



}</code></pre></div>
<h2 id="testteil2und3.cpp"><code>testTeil2und3.cpp</code></h2>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// Testrahmen fuer 2. und 3. Teilaufgabe</span>

<span class="ot">#include &lt;iostream&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="ot">#include &quot;FSA.h&quot;</span>
<span class="ot">#include &quot;RE.h&quot;</span>

<span class="ot">#include &quot;Transform.h&quot;</span>
<span class="ot">#include &quot;TestOrakel.h&quot;</span>

<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;string&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> std;


<span class="co">// Systematischer Test</span>

<span class="co">// Ein Testfall besteht aus einem regulaeren Ausdruck (RE)</span>
<span class="co">// und einem Eingabestring.</span>
<span class="co">// </span>
<span class="co">// Testorakel match ueberprueft ob string s enthalten in regex r.</span>
<span class="co">// </span>
<span class="co">// closure und Tranformater RE -&gt; NFA korrekt, falls Testorakel gleiches</span>
<span class="co">// Ergebnis liefert wie Ausfuehrung des resultierenden NFA.</span>

<span class="dt">bool</span> testClosureTransform(RE* r, string s) {
  NFA nfa = transform(r);
  FSA fsa(nfa);
  <span class="dt">bool</span> b1 = fsa.run(s);
  <span class="dt">bool</span> b2 = match(r,s);
  <span class="dt">bool</span> b = b1 == b2;

  cout &lt;&lt; <span class="st">&quot;Test case: &quot;</span> &lt;&lt; r-&gt;pretty() &lt;&lt; <span class="st">&quot;   &quot;</span> &lt;&lt; s &lt;&lt; <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;
  cout &lt;&lt; <span class="st">&quot;Test result: &quot;</span> &lt;&lt; b &lt;&lt; endl;

  <span class="kw">return</span> b;
}

<span class="dt">int</span> main() {

    RE* r3 = <span class="kw">new</span> Alt (<span class="kw">new</span> Phi(), <span class="kw">new</span> Ch(<span class="st">&#39;c&#39;</span>));
  
    testClosureTransform(r3, <span class="st">&quot;ab&quot;</span>);

    <span class="co">// TODO: mehr Tests</span>

}</code></pre></div>
</div>
</body>
</html>
